\chapter{Лабораторная работа №5\\\eng{RAM}-память} 

\par{Мы уже познакомились с многими блоками, из который состоят цифровые устройства. Последний базовый \quotes{строительный} блок, который мы рассмотрим в этом курсе — память с произвольным доступом (\eng{Random Access Memory}).}

\vspace{4mm}

\par{\eng{RAM} память в цифровых устройствах делится на три типа:}
  \begin{itemize}[noitemsep,topsep=0pt, after=\vspace{2pt}]
    \item Статическая память
    \item Динамическая память
    \item Энергонезависимая память
  \end{itemize}

\par{Статическая память по принципу работы похожа на набор регистров. Данные, которые были записаны в память, хранятся в ней, пока на цифровое устройство подается питание. Когда питание отключают, данные стираются из памяти.}

\par{Основным запоминающим элементом этого типа памяти является защелка. Такая память требует довольно большого количества ресурсов для своей реализации.}

\vspace{4mm}

\par{Динамическая память использует другой принцип хранения информации. В качестве элемента памяти в динамической памяти используются конденсаторы. Когда конденсатор заряжен — ячейка хранит \quotes{1}. Когда разряжен — \quotes{0}. Эта схема гораздо проще в реализации и требует существенно меньше ресурсов по сравнению со статической памятью. А значит на одном кристалле можно разместить большее количество памяти.}

\par{Но конденсатор неизбежно со временем разряжается через сопротивления утечки. Поэтому динамическая память требует постоянного обновления данных, которые были туда записаны. Обновление происходит благодаря внутреннему контроллеру, который проходит по всем адресам в памяти, считывая данные, а затем записывая эти же данные обратно и таким образом \quotes{обновляет} заряд конденсаторов.}

\par{Минусом динамической памяти является большое потребление тока, по сравнению со статической.}

\vspace{4mm}

\par{Наиболее известным представителем энергонезависимой памяти на данный момент является \eng{Flash} память. \eng{Flash} память базируется на транзисторах с плавающим затвором.}

\par{Выделяют два вида \eng{Flash} памяти — \eng{NOR} и \eng{NAND}. Последняя получила наибольшее настроение.}

\par{У \eng{Flash} памяти есть недостатки:}
  \begin{itemize}[noitemsep,topsep=0pt, after=\vspace{2pt}]
    \item высокая технологическая сложность и, соответственно, стоимость
    \item деградация ячеек памяти, при повторной перезаписи информации  (сотни тысяч операций записи для коммерческих продуктов, миллионы - 2012 год и сотни миллионов - 2014 год)
    \item деградация ячеек памяти при чтении (аналогично записи)
    \item блочная организация (удалить можно только блока информации целиком)
  \end{itemize}

\par{В рамках нашего курса мы познакомимся со статической памятью и \eng{Flash}-памятью, как наиболее часто применяющейся в качестве встроенной в цифровых устройствах.}

\par{Возможно, вы уже знаете основные принципы функционирования памяти в цифровой технике. Тем не менее, напомним, каким образом работает \eng{RAM} память.}

\par{Сначала разберем, какие входы и выходы необходимы для полноценной работы памяти. \textbf{\textit{Обратите внимание, что память является синхронным устройством и требует сигнала синхронизации}}:}

\begin{figure}[H]
	\centering
	\def\svgwidth{\columnwidth}
	\includesvg{images/lab_5/RAM_block}
	\caption{Входные и выходные сигналы RAM-памяти}
\end{figure}

\par{Как происходит запись данных в память и чтение из неё?}

\par{На вход \quotes{данные для записи} подаются данные, которые мы хотели бы записать в память. Одновременно с этим на вход \quotes{адрес записи} подается адрес ячейки, в которую мы хотели поместить входные данные. Запись происходит по положительному фронту сигнала синхронизации, когда вход \quotes{запись разрешена} находится в \quotes{1}.}

\par{Посмотрите на временную диаграмму записи данных в память:}


\begin{figure}[H]
\centering
\begin{tikztimingtable}[%
    timing/dslope=0.1,
    timing/.style={x=6ex,y=2.5ex},
    very thick,
    x=3ex,
    timing/rowdist=3.3ex,
    timing/name/.style={font=\sffamily\scriptsize},
]
	& 15{c} \\
	& 2.5L 1H 4L \\
	& 2.5D{00} 5D{FF} \\
	& 2.5D{00} 5D{01} \\
\extracode
\begin{pgfonlayer}{background}
\node [align=center,scale=0.7,text width=15ex] at (-8ex, -1.8ex) {Разрешение записи};
\node [align=center,scale=0.7,text width=15ex] at (-8ex, -5.5ex) {Данные для записи};
\node [align=center,scale=0.7,text width=15ex] at (-8ex, -9ex) {Адрес записи};
\node [align=center,scale=0.7] at (20ex, -12ex) {Данные \qeng{FF} будут записаны по адресу \quotes{01}};
\begin{scope}[semitransparent ,semithick]
\end{scope}
\end{pgfonlayer}
\end{tikztimingtable}
\caption{Временная диаграмма записи в память}
\end{figure}


\par{Чтение из \eng{RAM} памяти происходит следующим образом: на вход \quotes{адрес чтения} подается адрес ячейки, из которой мы хотим получить данные, затем на вход \quotes{разрешение чтения} подается \quotes{1}. По положительному фронту сигнала синхронизации данные выгружаются из памяти и становятся доступны для чтения:}


\begin{figure}[H]
\centering
\begin{tikztimingtable}[%
    timing/dslope=0.1,
    timing/.style={x=6ex,y=2.5ex},
    very thick,
    x=3ex,
    timing/rowdist=3.3ex,
    timing/name/.style={font=\sffamily\scriptsize},
]
	& 15{c} \\
	& 2.5L 1H 4L \\
	& 2.5D{00} 5D{01} \\
	& 4D{00} 3.5D{FF} \\
\extracode
\begin{pgfonlayer}{background}
\node [align=center,scale=0.7,text width=15ex] at (-8ex, -1.8ex) {Разрешение чтения};
\node [align=center,scale=0.7,text width=15ex] at (-8ex, -5.5ex) {Адрес чтения};
\node [align=center,scale=0.7,text width=15ex] at (-8ex, -9ex) {Считанные данные};
\node [align=center,scale=0.7,text width=27ex] at (10ex, -18ex) {По этому фронту\\необходимо\\защелкнуть данные,\\считанные из памяти};
\draw [->,thick] (10ex,-15ex) to [out=90,in=150] (17ex,-13ex) to [out=-30,in=220] (26.5ex,-11.5ex);
\draw [thick, color=black,dotted] (27ex,3ex) -- (27ex,-13ex);
\begin{scope}[semitransparent ,semithick]
\end{scope}
\end{pgfonlayer}
\end{tikztimingtable}
\caption{Временная диаграмма чтения из памяти}
\end{figure}


\par{\textbf{\textit{Обратите внимание, что как в случае записи, так и в случае чтения, управляющие сигналы \quotes{запись разрешена} и \quotes{чтение разрешено} для однократной операции записи или чтения должны иметь длительность равную одному такту.}}}

\vspace{4mm}

\par{Посмотрите на временную диаграмму, демонстрирующую запись большого количества данных в память:}


\begin{figure}[H]
\centering
\begin{tikztimingtable}[%
    timing/dslope=0.1,
    timing/.style={x=6ex,y=2.5ex},
    very thick,
    x=3ex,
    timing/rowdist=3.3ex,
    timing/name/.style={font=\sffamily\scriptsize},
]
	& 15{c} \\
	& 1.5L 4H 2L \\
	& 1.5D{09} 1D{0A} 1D{0B} 1D{0C} 1D{0D} 1D{0E} 1D{0F}\\
	& 1.5D{00} 1D{01} 1D{02} 1D{03} 1D{04} 1D{05} 1D{06}\\
\extracode
\begin{pgfonlayer}{background}
\node [align=center,scale=0.7,text width=15ex] at (-8ex, -1.8ex) {Разрешение записи};
\node [align=center,scale=0.7,text width=15ex] at (-8ex, -5.5ex) {Данные для записи};
\node [align=center,scale=0.7,text width=15ex] at (-8ex, -9ex) {Адрес записи};
\node [align=right,scale=0.7] at (20ex, -15ex) {Результат записи: \qeng{0A} по адресу \quotes{01}\\
								\qeng{0B} по адресу \quotes{02}\\
								\qeng{0C} по адресу \quotes{03}\\
								\qeng{0D} по адресу \quotes{04}};
\begin{scope}[semitransparent ,semithick]
\end{scope}
\end{pgfonlayer}
\end{tikztimingtable}
\caption{Временная диаграмма последовательной записи данных}
\end{figure}


\par{Обратите внимание на смещение считанных данных при последовательном чтении информации из памяти:}


\begin{figure}[H]
\centering
\begin{tikztimingtable}[%
    timing/dslope=0.1,
    timing/.style={x=6ex,y=2.5ex},
    very thick,
    x=3ex,
    timing/rowdist=3.3ex,
    timing/name/.style={font=\sffamily\scriptsize},
]
	& 15{c} \\
	& 1.5L 4H 2L \\
	& 1.5D{00} 1D{01} 1D{02} 1D{03} 1D{04} 2D{00}\\
	& 2.5D{ff} 1D{0A} 1D{0B} 1D{0C} 1D{0D} 1D{fF}\\
\extracode
\begin{pgfonlayer}{background}
\node [align=center,scale=0.7,text width=15ex] at (-8ex, -1.8ex) {Разрешение чтения};
\node [align=center,scale=0.7,text width=15ex] at (-8ex, -5.5ex) {Адрес записи};
\node [align=center,scale=0.7,text width=15ex] at (-8ex, -9ex) {Считанные данные};
\begin{scope}[semitransparent ,semithick]
\end{scope}
\end{pgfonlayer}
\end{tikztimingtable}
\caption{Временная диаграмма последовательного чтения из памяти}
\end{figure}


\par{Как же устроена статическая \eng{RAM}-память?}

\par{Общую структуру статической памяти можно представить следующим образом:}

\begin{figure}[H]
	\centering
	\def\svgwidth{\columnwidth}
	\includesvg{images/lab_5/static}
	\caption{Общая структура статической памяти}
\end{figure}

\par{Как мы уже говорили выше, использование триггеров и регистров для хранения большого количества данных оказалось не эффективно. \eng{RAM} память строится на основе массива запоминающих блоков.}

\par{Обычно каждый бит данных подается на столбец, а ячейка столбца, в которую произойдет запись, выбирается в зависимости от адреса. Т.е. нулевой бит, всегда подается на нулевой столбец, и, в зависимости от адреса, нулевой бит будет записан в конкретную ячейку нулевого столбца.}

\par{Чтение происходит подобным образом: адрес \quotes{выбирает} по одной ячейке из каждого столбца и из значений этих ячеек формируется вектор выходных данных.}

\par{Для того чтобы обеспечить управление работой массива памяти в ней присутствует схема управления и входной регистр для фиксации входных данных и адреса.}

\par{Обратите внимание, что схема управления тоже имеет регистр для хранения сигналов разрешения записи и разрешения чтения.}

\par{Данные, считанные из памяти поступают на защелку, поведение которой (разрешен ли приём или выбран режим хранения) также контролируется схемой управления.}

\par{На основе \eng{RAM} памяти строятся некоторые другие виды памяти.}

\par{Из них очень часто в цифровых устройствах встречается буфер. Буферный блок представляет собой память, организованную следующим образом: новые данные всегда записываются в \quotes{конец} памяти, а считываются всегда из её \quotes{начала}.}

\begin{figure}[H]
	\centering
	\def\svgwidth{\columnwidth}
	\includesvg{images/lab_5/buffer}
	\caption{Организация записи данных в буфер}
\end{figure}

\par{В англоязычной литературе такой блок памяти носит название \eng{FIFO} от словосочетания \eng{First In First Out} – Первый Пришел Первый Ушел. Название \eng{FIFO} настолько широко распространено, что оно практически вытеснило русское название \quotes{очередь}.}

\par{Так как данные всегда записываются в конец очереди, а читаются всегда из её начала, то интерфейс \eng{FIFO} не содержит адресной шины.}

\vspace{4mm}

\par{В основе \eng{FIFO}, как мы уже говорили, лежит \eng{RAM} память, а очередь организуется за счет управляющего блока, специально подготавливающего адреса чтения и записи.}

\par{Запись происходит с нулевого адреса. После помещения информации в память, управляющий блок увеличивает адрес на единицу. Чтение происходит точно также, начиная с нулевого адреса. Когда происходит чтение, адрес чтения также увеличивается на единицу. Управляющему блоку необходимо следить, чтобы адрес чтения не \quotes{перегонял} адрес записи.}

\par{Все ячейки, адреса которых находятся \quotes{между} адресом чтения и адресом записи — заполнены, а все ячейки, адреса которых находятся \quotes{снаружи} этих адресов — пусты.}

\begin{figure}[H]
	\centering
	\def\svgwidth{\columnwidth}
	\includesvg{images/lab_5/mem}
	\caption{Порядок чтения и записи в память}
\end{figure}

\par{Также управляющий блок вырабатывает сигналы, описывающие состояние очереди: \quotes{пуста} - означает, что в очереди нет данных и \quotes{полна} - означает, что в очереди нет места для новых данных.}

\par{Подумайте, каким образом устройство управления может выработать эти сигналы?}

\par{Также часто в \eng{FIFO} добавляют дополнительные признаки: \quotes{почти пуста} - означает, что в очереди только одно значение и \quotes{почти полна} - означает, что есть только одна свободная ячейка. Эти сигналы в некоторых случаях облегчают работу с \eng{FIFO}.}

\par{С точки зрения управления записью и чтением, \eng{FIFO} работает также, как и блок \eng{RAM} памяти, т.е. требует сигналов разрешения записи и разрешения чтения.}

\vspace{4mm}

\par{\eng{FIFO} часто применяют в качестве буфера, для того, чтобы сохранить быстро поступающую информацию и, в дальнейшем, обработать её. Такой блок часто можно встретить в контроллерах интерфейсов, где обмен данными часто происходит \quotes{волнами}.}

\begin{figure}[H]
	\centering
	\def\svgwidth{\columnwidth}
	\includesvg{images/lab_5/fifo}
	\caption{Запись пакетов данных в FIFO}
\end{figure}

\par{В цифровых устройствах для управления чтением из памяти и записью в неё часто используются конечные автоматы.}

\par{Продемонстрируем решение типовой задачи: спроектируем конечный автомат, задачей которого будет управление \eng{FIFO} и передатчиком некоторого интерфейса. Автомат будет по готовности передатчика при наличии данных в \eng{FIFO} выгружать из него новое значение и инициировать его передачу. Таким образом, мы реализуем буфер передачи.}

\vspace{4mm}

\par{Вот структурная схема устройства, которое мы хотим реализовать:}

\begin{figure}[H]
	\centering
	\def\svgwidth{\columnwidth}
	\includesvg{images/lab_5/struct}
	\caption{Структура устройства управления передачей данных}
\end{figure}

\par{Граф для конечного автомата будет выглядеть следующим образом:}

\begin{figure}[H]
	\centering
	\def\svgwidth{\columnwidth}
	\includesvg{images/lab_5/state_m}
	\caption{Граф работы конечного автомата}
\end{figure}

\par{В состоянии \quotes{ожидание} автомат ждёт готовности передатчика и появления данных в \eng{FIFO}. Затем, когда данные появляются и передатчик свободен, автомат переходит в состояние \quotes{запросить данные у \eng{FIFO}}, затем сразу же в состояние \quotes{Начать передачу} и, затем, снова в состояние \quotes{ожидание}.}

\par{Временная диаграмма будет выглядеть следующим образом:}


\begin{figure}[H]
\centering
\begin{tikztimingtable}[%
    timing/dslope=0.1,
    timing/.style={x=4.5ex,y=2.5ex},
    very thick,
    x=2ex,
    timing/rowdist=3.3ex,
    timing/name/.style={font=\sffamily\scriptsize},
]
				& 15{c} \\
	Состояние		& 1.5D{\eng{idle}} 1D{\eng{read}} 1D{\eng{start}} 4D{\eng{idle}}\\
	\eng{FIFO} пусто	& 0.5H 2L 5H \\
	Передатчик занят	& 3.5L 4H \\
	Сигнал инициирования передачи	& 2.5L 1H 4L \\
	\eng{FIFO} запрос чтения	& 1.5L 1H 5L \\
	Данные \eng{FIFO}	& 2.5D{91} 5D{A7} \\
\extracode
\begin{pgfonlayer}{background}
\draw [thick, color=black,dotted] (15.8ex,3ex) -- (15.8ex,-21ex);
\begin{scope}[semitransparent ,semithick]
\end{scope}
\end{pgfonlayer}
\end{tikztimingtable}
\caption{Временная диаграмма последовательного чтения из памяти}
\end{figure}


\par{Внимательно изучите временную диаграмму. Обратите внимание на то, каким образом спроектирован конечный автомат. Отметьте, что сигнал инициирования передачи совпадает с состоянием \qeng{start}, а сигнал запроса чтения для \eng{FIFO} совпадает с состоянием \qeng{read}. Также заметьте, что инициирование передачи происходит как раз в тот момент, когда данные с \eng{FIFO} уже готовы для чтения.}

\par{Приступим к описанию нашего модуля, используя \eng{FIFO} и передатчик, в качестве компонентов.}

\lstinputlisting[caption={Описание проектируемого устройства на языке \eng{Verilog HDL}}, ]{./code_examples/lab_5/example_lab6.v}

\section{Задание лабораторной работы:}

\par{Изучить разработку к лабораторной работе.}

\par{Разработать цифровое устройство, функционирующее согласно следующим принципам:}

\par{Нажатие кнопки приводит к увеличению текущего значения счётчика на единицу. Одновременно с этим текущее значение счётчика должно быть записано в буфер \eng{FIFO}. Если в \eng{FIFO} есть данные, то их выгрузка должна производиться один раз в секунду (одно слово в секунду). Выгруженное значение должно отображаться на семисегментных индикаторах в шестнадцатеричной форме.}

\par{Провести моделирование работы данного цифрового устройства и продемонстрировать результат.}

\par{Получить файл конфигурации для ПЛИС учебного стенда и продемонстрировать работу устройства.}

\section{Вопросы к защите лабораторной работы}

\par{Что такое \eng{RAM}-память?}

\par{Изобразите обобщенную структуру \eng{RAM}-памяти.}

\par{\eng{RAM}-память это синхронное или асинхронное устройство?}

\par{Опишите все входные и выходные сигналы \eng{RAM} памяти, известные вам.}

\par{Нарисуйте временную диаграмму записи значения в \eng{RAM} память.}

\par{Нарисуйте временную диаграмму чтения значения из \eng{RAM} памяти.}

\par{Как функционирует буфер \eng{FIFO}?}

\par{Опишите все входные и выходные сигналы \eng{FIFO} памяти, известные вам.}