\documentclass[a5paper, DIV=14, headings=openany, twoside=true,fontsize=10pt, titlepage]{scrreprt}
\usepackage[T1,T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english, russian]{babel} 
\usepackage{indentfirst}
\usepackage{subfig}
\usepackage{graphicx}
\usepackage{float}
\usepackage{import}
\usepackage[rgb]{xcolor}
\usepackage{svg}
\usepackage{listingsutf8}
\usepackage{scrhack}
\usepackage{enumitem}
\usepackage{bm}
\usepackage{verbatimbox}

\usepackage{longtable}

% \usepackage[bottom]{footmisc}
\raggedbottom

%\usepackage{float}
%\usepackage{pxfonts}
\usepackage{caption}%[2013/01/01]
%\usepackage{inconsolata}
\usepackage{dejavu}
\usepackage[justification=centering]{caption}
%\lstset{basicstyle=\ttfamily}
\usepackage{varwidth}
\definecolor{light-gray}{gray}{0.97}
\renewcommand*\chapterformat{}
\renewcommand\textbullet{\ensuremath{\bullet}}

\usepackage{tikz-timing}
%\usetikztiminglibrary[rising arrows]{clockarrows}
\usetikztiminglibrary[arrow tip=latex, rising arrows]{clockarrows}
\usetikztiminglibrary{nicetabs}
\usepackage{xparse} % NewDocumentCommand, IfValueTF, IFBooleanTF

\lstset{inputencoding=utf8, extendedchars=\true, basicstyle=\ttfamily}
\lstset{language=Verilog,
        numbers=left,
        firstnumber=1,
        xleftmargin=2em,
        numberfirstline=true,
        captionpos=b,
        backgroundcolor = \color{light-gray},
        aboveskip=1em,
        belowskip=1em}

\setkomafont{disposition}{\normalfont}
%\addtokomafont{chapter}{\large}
\captionsetup{belowskip=10pt,aboveskip=8pt}
%\captionsetup[lstlisting]{justification=centering}
%\lstloadlanguages{Verilog}
%\pretolerance=2000
%\hyphenpenalty=2000

\usepackage{scrlayer-scrpage}

\let\tempmargin\oddsidemargin
\let\oddsidemargin\evensidemargin
\let\evensidemargin\tempmargin
\reversemarginpar

\newcommand{\nsig}[1]{$\overline{\mbox{#1}}$}
\newcommand*\xor{\mathbin{\oplus}}
\newcommand{\quotes}[1]{«#1»}
\newcommand{\eng}[1]{\foreignlanguage{english}{#1}}
\newcommand{\qeng}[1]{\quotes{\eng{#1}}}
\newcommand{\kword}[1]{\eng{\textbf{#1}}}

\usepackage{parskip}
\setlength{\parindent}{15pt}
\setlength{\parskip}{2pt}

\begin{document}
\rofoot*{\pagemark}
\lofoot*{}
\refoot*{}
\lefoot*{\pagemark}

\sloppy

\title{Лабораторный практикум}
\author{}
\subject{}
\subtitle{\quotes{Проектирование цифровых устройств с помощью \eng{Verilog HDL}}}
\titlehead{}
\publishers{}
\date{}


\maketitle{}


\chapter{Лабораторная работа №1\\Введение в Verilog HDL} 
\section{Возникновение языков описания цифровой аппаратуры}

\par{Цифровые устройства — это устройства, предназначенные для приёма и обработки цифровых сигналов. Цифровыми называются сигналы, которые можно рассматривать в виде набора дискретных уровней. В цифровых сигналах информация кодируется в виде конкретного уровня напряжения. Как правило выделяется два уровня — логический «0» и логическая «1».}

\par{Цифровые устройства стремительно развиваются с момента изобретения электронной лампы, а затем транзистора. Со временем цифровые устройства стали компактнее, уменьшилось их энергопотребление, возрасла вычислительная мощность. Так же разительно возросла сложность их структуры.}

\par{Графические схемы, которые применялись для проектирования цифровых устройств на ранних этапах развития, уже не могли эффективно использоваться. Потребовался новый инструмент разработки, и таким инструментом стали языки описания аппаратной части цифровых устройств (\eng{Hardware Description Languages, HDL}), которые описывали цифровые структуры формализованным языком, чем-то похожим на язык программирования.}

\par{Совершенно новый подход к описанию цифровых схем, реализованный в языках \eng{HDL}, заключается в том, что с помощью их помощью можно описывать не только структуру, но и поведение цифрового устройства.Окончательная структура цифрового устройства получается путём обработки таких смешанных описаний специальной программой — синтезатором.}

\par{Такой подход существенно изменил процесс разработки цифровых устройств, превратив громоздкие, тяжело читаемые схемы в относительно простые и доступные описания поведения.}

\par{В данном курсе мы рассмотрим язык описания цифровой аппаратуры \eng{Verilog HDL} — одни из наиболее распространённых на текущий момент. И начнём мы с разработки наиболее простых цифровых устройств — логических вентилей.}

\section{\eng{HDL} описания логических вентилей}

\par{Логические вентили реализуют функции алгебры логики: И, ИЛИ, Исключающее ИЛИ, НЕ. Напомним их таблицы истинности:}

\begin{table}[!htbp]
\parbox{.45\linewidth}{
\centering
\begin{tabular}{c|c|c}
$a$&$b$&$a \cdot b$\\
\hline
$0$ & $0$ & $0$ \\
$0$ & $1$ & $0$ \\
$1$ & $0$ & $0$ \\
$1$ & $1$ & $1$ \\
\end{tabular}
\caption{И}
} \hfill
\parbox{.45\linewidth}{
\centering
\begin{tabular}{c|c|c}

$a$&$b$&$a | b$\\
\hline
$0$ & $0$ & $0$ \\
$0$ & $1$ & $1$ \\
$1$ & $0$ & $1$ \\
$1$ & $1$ & $1$ \\

\end{tabular}
\caption{ИЛИ}
}\hfill
\parbox{.45\linewidth}{
\centering
\begin{tabular}{c|c|c}
$a$&$b$&$a \xor b$\\
\hline
$0$ & $0$ & $0$ \\
$0$ & $1$ & $1$ \\
$1$ & $0$ & $1$ \\
$1$ & $1$ & $0$ \\
\end{tabular}
\caption{Исключающее ИЛИ}
}\hfill
\parbox{.45\linewidth}{
\centering
\begin{tabular}{c|c}
$a$&$\bar{a}$\\
\hline
$0$ & $1$\\
$1$ & $0$\\
\end{tabular}
\caption{НЕ}
}
\end{table}

\par{Начнём знакомиться с \eng{Verilog HDL} с описания логического вентиля \quotes{И}. Ниже приведен код, описывающий вентиль с точки зрения его структуры:}

 \noindent
 \begin{minipage}{\linewidth}
  \lstinputlisting[caption={Модуль, описывающий вентиль \quotes{И}}]{./code_examples/and_gate.v}
 \end{minipage}

\par{Описанный выше модуль можно представить как некоторый \quotes{ящик}, в который входит 2 провода с названиями \emph{\qeng{a}} и \emph{\qeng{b}} и из которого выходит один провод с названием \emph{\qeng{result}}. Внутри этого блока результат выполнения операции \quotes{И} (в синтаксисе Verilog записывается как \quotes{\&}) над входами соединяют с выходом.}
\par{Схемотично изобразим этот модуль:}

\begin{figure}[H]
\centering
\def\svgwidth{\columnwidth}
\includesvg{pict_1_1}
\caption{Структура модуля \qeng{and\_gate}}
\end{figure}

%\begin{minipage}{\linewidth}
\par{Аналогично опишем все оставшиеся вентили:}

\noindent
\begin{minipage}{\linewidth}
\lstinputlisting[caption={Модуль, описывающий вентиль \quotes{ИЛИ}}]{./code_examples/or_gate.v}
\end{minipage}

\noindent
\begin{minipage}{\linewidth}
\lstinputlisting[caption={Модуль, описывающий вентиль \mbox{\quotes{Исключающее ИЛИ}}}]{./code_examples/xor_gate.v}
\end{minipage}

\noindent
\begin{minipage}{\linewidth}
\lstinputlisting[caption={Модуль, описывающий вентиль \quotes{НЕ}}]{./code_examples/not_gate.v}
\end{minipage}

\par{В проектировании цифровых устройств логические вентили наиболее часто используются для формулировки и проверки сложных условий, например:}

% \noindent
% \begin{minipage}{\linewidth}
\lstinputlisting[caption={Пример использования логических вентилей}]{./code_examples/logic_gatex_example.v}
% \end{minipage}

\par{Условие будет выполняться либо когда \emph{не} выполнено условие \emph{\qeng{c}}, либо когда одновременно выполняются условия \emph{\qeng{a}} и \emph{\qeng{b}}. \emph{Здесь и далее под условием понимается логический сигнал, отражающий его истинность.}}
\par{В качестве входов, выходов и внутренних соединений в блоках могут использоваться шины — группы проводов. Ниже приведен пример работы с шинами:}

% \noindent
% \begin{minipage}{\linewidth}
\lstinputlisting[caption={Модуль, описывающий побитовое \quotes{ИЛИ} \mbox{между двумя шинами}},float,floatplacement=H]{./code_examples/bus_or.v}
% \end{minipage}

\par{Это описание описывает побитовое \quotes{ИЛИ} между двумя шинами по 8 бит. То есть описываются восемь логических вентилей \quotes{ИЛИ}, каждый из которых имеет на входе соответствующие разряды из шины \emph{\qeng{x}} и шины \emph{\qeng{y}}.}

\par{При использовании шин можно в описании использовать конкретные биты шины и группы битов. Для этого используют квадратные скобки после имени шины:}

% \noindent
% \begin{minipage}{\linewidth}
\lstinputlisting[caption={Модуль, демонстрирующий \mbox{битовую адресацию шин}}, ]{./code_examples/bitwise_ops.v}
% \end{minipage}

\par{Такому описанию соответствует следующая структурная схема, приведённая на Рис.\ref{fig:bitwiseops}}

\begin{figure}[H]
\centering
\def\svgwidth{\columnwidth}
\includesvg{pict_1_2}
\caption{Структура модуля \qeng{bitwise\_ops}}
\label{fig:bitwiseops}
\end{figure}

\par{Впрочем, реализация ФАЛ с помощью логических вентилей не всегда представляется удобной. Допустим нам нужно описать таблично-заданную ФАЛ. Тогда описания этой функции при помощи логических вентилей нам придётся сначала минимизировать её и только после этого, получив логическое выражение (которое, несмотря на свою минимальность, не обязательно является коротким), сформулировать его с помощью языка \eng{Verilog HDL}. Как видно, ошибку легко допустить на любом из этих этапов.}
 
\par{Одно из главных достоинств \eng{Verilog HDL} — это возможность описывать поведение цифровых устройств вместо описания их структуры.}
 
\par{Программа-синтезатор анализирует синтаксические конструкции поведенческого описания цифрового устройства на \eng{Verilog HDL}, проводит оптимизацию и, в итоге, вырабатывает структуру, реализующую цифровое устройство, которое соответствует заданному поведению.}
 
\par{Используя эту возможность, опишем таблично-заданную ФАЛ на \eng{Verilog HDL}:}
 
% \noindent
% \begin{minipage}{\linewidth}
  \lstinputlisting[caption={Пример описания таблично-заданной ФАЛ на \eng{Verilog HDL}}, ]{./code_examples/function_example.v}
% \end{minipage}
 
  \par{Описание, приведённое выше, определяет $y$, как таблично-заданную функцию, которая равна нулю на наборах 0, 2, 5, 6, 7 и единице на всех остальных наборах.}
 
\par{Остановимся подробнее на новых синтаксических конструкциях:}
\par{Описание нашего модуля начинается с создания трёхбитной шины \qeng{x\_bus} на строке 7.}
\par{После создания шины \qeng{x\_bus}, на она подключается к объединению проводов \qeng{x2}, \qeng{x1} и \qeng{x0} с помощью оператора \eng{assign} на строке 8.}

 
\par{Затем начинается функциональный блок \kword{always}, на котором мы остановимся подробнее.}
\par{\eng{Verilog HDL} описывает цифровую аппаратуру, которая существует вся одновременно, но инструменты анализа и синтеза описаний являются программами и выполняются последовательно на компьютере. Так возникла необходимость последовательной программе «рассказать» про то, какие события приводят к срабатыванию тех или иных участков кода. Сами эти участки назвали процессами. Процессы обозначаются ключевым словом \kword{always}.}
 
\par{В скобках после символа @ указывается так называемый \emph{список чувствительности процесса}, т.е. те сигналы, изменение которых должно приводить к пересчёту результатов выолнения процесса.}

\par{Например, результат ФАЛ надо будет пересчитывать каждый раз, когда изменился входной вектор (любой бит входного вектора, т.е. любая переменная ФАЛ). Эти процессы можно назвать блоками, или частями будущего цифрового устройтсва.}

\par{Новое ключевое слово \kword{reg} здесь необходимо потому, что в выходной вектор происходит запись, а запись в языке \eng{Verilog HDL} разрешена только в «регистры» — специальные «переменные», предусмотренные в языке. Данная концепция и ключевое слово reg будет рассмотрено гораздо подробнее в следующей лабораторной работе.}

\par{Оператор \kword{<=} называется оператором \emph{неблокирующего присваивания}. В результате выполнения этого оператора то, что стоит справа от него, «помещается» («кладется», «перекладывается») в регистр, который записан слева от него. Операции неблокирующего присваивания происходят одновременно по всему процессу.}

\par{Оператор \kword{case} описывает выбор действия в зависимости от анализируемого значения. В нашем случае анализируется значение шины \qeng{x\_bus}. Ключевое слово \kword{default} используется для обозначения всех остальных (не перечисленных) вариантов значений.}

\par{Константы и значения в языке \eng{Verilog HDL} описываются следующим образом: сначала указывается количество бит, затем после апострофа с помощью буквы указывается формат и, сразу за ним, записывается значение числа в этом формате.}

% \noindent
% \begin{minipage}{\textwidth}
 % \setlength{\parindent}{15pt}
 % \setlength{\parskip}{0pt}
\par{Возможные форматы:
  \begin{itemize}[noitemsep,topsep=0pt, after=\vspace{2pt}]
  \item b – бинарный, двоичный;
  \item h – шестнадцатеричный;
  \item d – десятичный.
\end{itemize}}
% \end{minipage}

\par{Немного расширив это описание, легко можно определить не одну, а сразу несколько ФАЛ одновременно. Для упрощения записи сразу объединим во входную шину все переменные. В выходную шину объединим значения функций:}

% \noindent
% \begin{minipage}{\linewidth}
  \lstinputlisting[caption={Описание дешифратора на языке \eng{Verilog HDL}}, ]{./code_examples/decoder.v}
% \end{minipage}

\par{Теперь нам удалось компактно записать четыре функции, каждая от трёх переменных:
\begin{itemize}[noitemsep,topsep=2pt,label={}]
  \item $y_0=f(x_2,x_1,x_0);$
  \item $y_1=f(x_2,x_1,x_0);$
  \item $y_2=f(x_2,x_1,x_0);$
  \item $y_3=f(x_2,x_1,x_0).$
\end{itemize}}

\par{Но, если мы посмотрим на только что описанную конструкцию под другим углом, мы увидим, что это описание можно трактовать следующим образом: \quotes{поставить каждому возможному входному вектору $x$ в соответствие заранее определенный выходной вектор $y$}. Такое цифровое устройство называют \emph{дешифратором}.}

\par{В цифровой схемотехнике принято обозначать дешифратор следующим образом:}

% \begin{figure}[H]
% \centering
% \def\svgwidth{\columnwidth}
% \includesvg{pic_decoder}
% \caption{Графическое обозначение дешифратора}
% \end{figure}
% \end{minipage}

\par{Заметим, что длины векторов не должны совпадать, а единственным условием является полное покрытие всех возможных входных векторов, что, например, может достигаться использованием условия \kword{default} в операторе \kword{case}.}

\par{Дешифраторы активно применяются при разработке цифровых устройств. В большинстве цифровых устройств в явном или неявном виде можно встретить дешифратор.}

\par{Рассмотрим еще один интересный набор ФАЛ:}

% \noindent
% \begin{minipage}{\linewidth}
  \lstinputlisting[caption={Описание мультиплексора на языке \eng{Verilog HDL}}, ]{./code_examples/multiplexer.v}
% \end{minipage}

\par{Что можно сказать об этом описании? Выходной вектор $y$ — это результат работы трёх ФАЛ, каждая из которых является функцией 6 переменных. Так, $y_0 = f(a_0, b_0, c_0, d_0, s_1, s_0)$.}

\par{Анализируя оператор \kword{case}, можно увидеть, что главную роль в вычислении значения ФАЛ играет вектор $s$, в результате проверки которого выходу ФАЛ присваивается значение \quotes{выбранной} переменной.}

\par{Получившееся устройство называется \emph{мультиплексор}}.

\par{Мультиплексор работает подобно коммутирующему ключу, замыкающему выход с выбранным входом. Для выбора входа мультиплексору нужен сигнал управления.}

% \noindent
% \begin{minipage}{\textwidth}
% \setlength{\parindent}{15pt}
% \setlength{\parskip}{0pt}
\par{Ниже показано как изображается мультиплексор на рисунках цифровых сем:}

% \begin{figure}[H]
% \centering
% \def\svgwidth{\columnwidth}
% \includesvg{pic_mux}
% \caption{Графическое обозначение мультиплексора}
% \end{figure}
% \end{minipage}
% \end{minipage}

\par{Особенно хочется отметить, что на самом деле никакой \quotes{проверки} сигнала управления не существует и уж тем более не существует \quotes{коммутации}, ведь мультиплексор — это таблично-заданная ФАЛ. Результат выполнения этой ФАЛ выглядит так, как будто происходит \quotes{подключение} \quotes{выбранной} входной шины к выходной.}

\par{Приведём для наглядности таблицу, задающую ФАЛ для одного бита выходного вектора (число ФАЛ в мультиплексоре и, следовательно, число таблиц, равняется числу бит в выходном векторе). Для краткости выпишем таблицу наборами строк вида: $f(s_1, s_0, a_0, b_0, c_0, d_0) = y_0$ в четыре столбца.}
\par{Обратите внимание, что в качестве старших двух бит входного вектора для удобства записи и анализа мы выбрали переменные \quotes{управляющего} сигнала, а выделение показывает какая переменная \quotes{поступает} на выход функции $f$:}
\begin{longtable}{ c c c c}

  $f(00\bm{0}000) = 0$ & 
  $f(010\bm{0}00) = 0$ & 
  $f(1000\bm{0}0) = 0$ & 
  $f(11000\bm{0}) = 0$ \\ 

  $f(00\bm{0}001) = 0$ & 
  $f(010\bm{0}01) = 0$ & 
  $f(1000\bm{0}1) = 0$ & 
  $f(11000\bm{1}) = 1$ \\ 

  $f(00\bm{0}010) = 0$ & 
  $f(010\bm{0}10) = 0$ & 
  $f(1000\bm{1}0) = 1$ & 
  $f(11001\bm{0}) = 0$ \\ 

  $f(00\bm{0}011) = 0$ & 
  $f(010\bm{0}11) = 0$ & 
  $f(1000\bm{1}1) = 1$ & 
  $f(11001\bm{1}) = 1$ \\ 

  $f(00\bm{0}100) = 0$ & 
  $f(010\bm{1}00) = 1$ & 
  $f(1001\bm{0}0) = 0$ & 
  $f(11010\bm{0}) = 0$ \\ 

  $f(00\bm{0}101) = 0$ & 
  $f(010\bm{1}01) = 1$ & 
  $f(1001\bm{0}1) = 0$ & 
  $f(11010\bm{1}) = 1$ \\ 

  $f(00\bm{0}110) = 0$ & 
  $f(010\bm{1}10) = 1$ & 
  $f(1001\bm{1}0) = 1$ & 
  $f(11011\bm{0}) = 0$ \\ 

  $f(00\bm{0}111) = 0$ & 
  $f(010\bm{1}11) = 1$ & 
  $f(1001\bm{1}1) = 1$ & 
  $f(11011\bm{1}) = 1$ \\ 

  $f(00\bm{1}000) = 1$ & 
  $f(011\bm{0}00) = 0$ & 
  $f(1010\bm{0}0) = 0$ & 
  $f(11100\bm{0}) = 0$ \\ 

  $f(00\bm{1}001) = 1$ & 
  $f(011\bm{0}01) = 0$ & 
  $f(1010\bm{0}1) = 0$ & 
  $f(11100\bm{1}) = 1$ \\ 

  $f(00\bm{1}010) = 1$ & 
  $f(011\bm{0}10) = 0$ & 
  $f(1010\bm{1}0) = 1$ & 
  $f(11101\bm{0}) = 0$ \\ 

  $f(00\bm{1}011) = 1$ & 
  $f(011\bm{0}11) = 0$ & 
  $f(1010\bm{1}1) = 1$ & 
  $f(11101\bm{1}) = 1$ \\ 

  $f(00\bm{1}100) = 1$ & 
  $f(011\bm{1}00) = 1$ & 
  $f(1011\bm{0}0) = 0$ & 
  $f(11110\bm{0}) = 0$ \\ 

  $f(00\bm{1}101) = 1$ & 
  $f(011\bm{1}01) = 1$ & 
  $f(1011\bm{0}1) = 0$ & 
  $f(11110\bm{1}) = 1$ \\ 

  $f(00\bm{1}110) = 1$ & 
  $f(011\bm{1}10) = 1$ & 
  $f(1011\bm{1}0) = 1$ & 
  $f(11111\bm{0}) = 0$ \\ 

  $f(00\bm{1}111) = 1$ & 
  $f(011\bm{1}11) = 1$ & 
  $f(1011\bm{1}1) = 1$ & 
  $f(11111\bm{1}) = 1$ \\ 
\end{longtable}

% \begin{figure}[H]
% \begin{tikztimingtable}[%
%     timing/dslope=0.1,
%     timing/.style={x=5ex,y=2ex},
%     x=5ex,
%     timing/rowdist=3ex,
%     timing/name/.style={font=\sffamily\scriptsize}
% ]
% CLK         & 18{c} \\
% FRAME     & 2u 6L H U \\
% \nsig{AD} [31:0]   & 2u 1D{addr} 1U{} 1D{$d_1$} D{$d_1 '$} D{$d_2$} 2D{$d_3$} U \\
% C/BE[3:0] & 2u 1D{0010} 6D{BE\#} U  \\
% IRDY      & UU 4L HLH \\
% TRDY       & UU HLH 3L H \\
% DEVSEL     & 2U 6L H\\
% \extracode
% \begin{pgfonlayer}{background}
% \begin{scope}[semitransparent ,semithick]
% \vertlines[darkgray,dotted]{0.5,1.5 ,...,8.0}
% \end{scope}
% \end{pgfonlayer}
% \end{tikztimingtable}
% \caption{Временная диаграмма операции чтения шины \eng{PCI}}
% \end{figure}

% \chapter{Лабораторная работа №6\\\eng{FLASH} память} 
% \section{Возникновение \eng{FLASH}-памяти}
% \par{Ни один из блоков цифровых устройств, которые мы рассмотрели ранее не способен хранить информацию при отсутствии питания.}
% \par{На заре вычислительной техники, данные в цифровое устройство после подачи питания загружали с таких носителей, как перфокарты и, позже, магнитные ленты. Ещё позже для целей хранения информации при отсутствии питания были разработаны накопители на жёстких магнитных дисках, которые известны нам по аббревиатуре \qeng{HDD}.}
% \par{Энергонезависимые накопители информации обладают как преимуществами, так и недостатками по сравнению с энергозависимой памятью.} 
% \par{Как правило, энергонезависимая память существенно уступает по скорости работы \eng{RAM}-памяти. Это ограничение удалось преодолеть только недавно: в 2016 году широкой общественности была представлена постоянная память, где информация хранится в виде спина электрона. Такая память по скорости работы не уступает современной \eng{RAM}-памяти, такой как \eng{DDR5}. Но подобная память ещё долгое время будет оставаться недоступной для рядового пользователя из-за высокой стоимости.}
% \par{На данный момент наиболее широко используемая энергонезависимая память - это память типа \eng{FLASH}.}
% \par{В качестве элемента хранения информации такая память использует транзистор с плавающим затвором, где состояние затвора определяет бит хранимой информации.}
% %\includesvg{pict_6_1}
% % \begin{figure}[H]
% % \centering
% % \def\svgwidth{\columnwidth}
% % \includesvg{no_image}
% % \caption{Ячейка \eng{FLASH}-памяти}
% % \end{figure}
% 
% 
% \begin{samepage}
% \par{Из-за использования транзистора с плавающим затвором, у \eng{FLASH}-памяти есть характерные особенности:
%   \begin{itemize}
%     \item Запись значения возможна только из логической \quotes{1} в логический \quotes{0};
%     \item Удаление информации возможно из группы ячеек одновременно (блока);
%     \item Удаление и запись информации приводят к деградации ячеек памяти;
%     \item Чтение также приводит к деградации ячеек памяти, но в меньшей степени.
%   \end{itemize}}
% \end{samepage}
% 
% \par{Из-за физических процессов, протекающих в транзисторах во время записи значений в память и очистки содержимого.}
\end{document}
