\pdfobjcompresslevel=0
\pdfcompresslevel=0

\documentclass[a5paper, DIV=14, headings=openany, twoside=true,fontsize=10pt, titlepage]{scrreprt}
\usepackage[T1,T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english, russian]{babel} 
\usepackage{indentfirst}
\usepackage{subfig}
\usepackage{graphicx}
\usepackage{float}
\usepackage{import}
\usepackage[rgb]{xcolor}
\usepackage{svg}
\usepackage{listingsutf8}
\usepackage{scrhack}
\usepackage{enumitem}
\usepackage{bm}
\usepackage{verbatimbox}

\usepackage{tabularx}

\usepackage{longtable}

% \usepackage[bottom]{footmisc}
\raggedbottom

%\usepackage{float}
%\usepackage{pxfonts}
\usepackage{caption}%[2013/01/01]
%\usepackage{inconsolata}
\usepackage{dejavu}
\usepackage[justification=centering]{caption}
%\lstset{basicstyle=\ttfamily}
\usepackage{varwidth}
\definecolor{light-gray}{gray}{0.97}
\renewcommand*\chapterformat{}
\renewcommand\textbullet{\ensuremath{\bullet}}

\usepackage{tikz-timing}
%\usetikztiminglibrary[rising arrows]{clockarrows}
\tikzset{timing/z/.style={black}}
\tikzset{timing/Z/.style={black}}
\usetikztiminglibrary[arrow tip=latex, rising arrows]{clockarrows}
\usetikztiminglibrary{nicetabs}
\usepackage{xparse} % NewDocumentCommand, IfValueTF, IFBooleanTF

\lstset{inputencoding=utf8, extendedchars=\true, basicstyle=\ttfamily}
\lstset{language=Verilog,
        numbers=left,
        firstnumber=1,
        xleftmargin=2em,
        numberfirstline=true,
        captionpos=b,
        backgroundcolor = \color{light-gray},
        aboveskip=1em,
        belowskip=1em}

\setkomafont{disposition}{\normalfont}
%\addtokomafont{chapter}{\large}
\captionsetup{belowskip=0pt,aboveskip=8pt}
%\captionsetup[lstlisting]{justification=centering}
%\lstloadlanguages{Verilog}
%\pretolerance=2000
%\hyphenpenalty=2000
\usepackage{layouts}
\setlength{\intextsep}{0.5\baselineskip plus 0.1\baselineskip minus 0.1\baselineskip}

\usepackage{scrlayer-scrpage}

\let\tempmargin\oddsidemargin
\let\oddsidemargin\evensidemargin
\let\evensidemargin\tempmargin
\reversemarginpar

\newcommand{\nsig}[1]{$\overline{\mbox{#1}}$}
\newcommand*\xor{\mathbin{\oplus}}
\newcommand{\quotes}[1]{«#1»}
\newcommand{\eng}[1]{\foreignlanguage{english}{#1}}
\newcommand{\qeng}[1]{\quotes{\eng{#1}}}
\newcommand{\kword}[1]{\eng{\textbf{#1}}}

\usepackage{parskip}
\setlength{\parindent}{15pt}
\setlength{\parskip}{2pt}

%Patch for Tikz
\makeatletter
\begingroup\expandafter\expandafter\expandafter\endgroup
\expandafter\ifx\csname pgfutil@addpdfresource@extgs\endcsname\relax
\else
  \AtBeginDocument{%
    % \pgf@sys@addpdfresource@extgs@plain{%
    \pgfutil@addpdfresource@extgs{%
      \TRP@list
    }%
  }%  
  \let\TRP@addresource\relax
\fi
\makeatother

\begin{document}
\rofoot*{\pagemark}
\lofoot*{}
\refoot*{}
\lefoot*{\pagemark}

\sloppy

\title{Лабораторный практикум}
\author{}
\subject{}
\subtitle{\quotes{Проектирование цифровых устройств с помощью \eng{Verilog HDL}}}
\titlehead{}
\publishers{}
\date{}


\maketitle{}


\chapter{Лабораторная работа №1\\Введение в Verilog HDL} 
\section{Возникновение языков описания цифровой аппаратуры}

\par{Цифровые устройства — это устройства, предназначенные для приёма и обработки цифровых сигналов. Цифровыми называются сигналы, которые можно рассматривать в виде набора дискретных уровней. В цифровых сигналах информация кодируется в виде конкретного уровня напряжения. Как правило выделяется два уровня — логический «0» и логическая «1».}

\par{Цифровые устройства стремительно развиваются с момента изобретения электронной лампы, а затем транзистора. Со временем цифровые устройства стали компактнее, уменьшилось их энергопотребление, возрасла вычислительная мощность. Так же разительно возросла сложность их структуры.}

\par{Графические схемы, которые применялись для проектирования цифровых устройств на ранних этапах развития, уже не могли эффективно использоваться. Потребовался новый инструмент разработки, и таким инструментом стали языки описания аппаратной части цифровых устройств (\eng{Hardware Description Languages, HDL}), которые описывали цифровые структуры формализованным языком, чем-то похожим на язык программирования.}

\par{Совершенно новый подход к описанию цифровых схем, реализованный в языках \eng{HDL}, заключается в том, что с помощью их помощью можно описывать не только структуру, но и поведение цифрового устройства.Окончательная структура цифрового устройства получается путём обработки таких смешанных описаний специальной программой — синтезатором.}

\par{Такой подход существенно изменил процесс разработки цифровых устройств, превратив громоздкие, тяжело читаемые схемы в относительно простые и доступные описания поведения.}

\par{В данном курсе мы рассмотрим язык описания цифровой аппаратуры \eng{Verilog HDL} — одни из наиболее распространённых на текущий момент. И начнём мы с разработки наиболее простых цифровых устройств — логических вентилей.}

\section{\eng{HDL} описания логических вентилей}

\par{Логические вентили реализуют функции алгебры логики: И, ИЛИ, Исключающее ИЛИ, НЕ. Напомним их таблицы истинности:}

\begin{table}[!htbp]
  \parbox{.45\linewidth}{
    \centering
  \begin{tabular}{c|c|c}
    $a$&$b$&$a \cdot b$\\
    \hline
    $0$ & $0$ & $0$ \\
    $0$ & $1$ & $0$ \\
    $1$ & $0$ & $0$ \\
    $1$ & $1$ & $1$ \\
  \end{tabular}
  \caption{И}
} \hfill
  \parbox{.45\linewidth}{
    \centering
  \begin{tabular}{c|c|c}

    $a$&$b$&$a | b$\\
    \hline
    $0$ & $0$ & $0$ \\
    $0$ & $1$ & $1$ \\
    $1$ & $0$ & $1$ \\
    $1$ & $1$ & $1$ \\

  \end{tabular}
  \caption{ИЛИ}
}\hfill
  \parbox{.45\linewidth}{
    \centering
  \begin{tabular}{c|c|c}
    $a$&$b$&$a \xor b$\\
    \hline
    $0$ & $0$ & $0$ \\
    $0$ & $1$ & $1$ \\
    $1$ & $0$ & $1$ \\
    $1$ & $1$ & $0$ \\
  \end{tabular}
  \caption{Исключающее ИЛИ}
}\hfill
  \parbox{.45\linewidth}{
    \centering
  \begin{tabular}{c|c}
    $a$&$\bar{a}$\\
    \hline
    $0$ & $1$\\
    $1$ & $0$\\
  \end{tabular}
  \caption{НЕ}
}
\end{table}

\par{Начнём знакомиться с \eng{Verilog HDL} с описания логического вентиля \quotes{И}. Ниже приведен код, описывающий вентиль с точки зрения его структуры:}

\noindent
\begin{minipage}{\linewidth}
 \lstinputlisting[caption={Модуль, описывающий вентиль \quotes{И}}]{./code_examples/and_gate.v}
\end{minipage}

\par{Описанный выше модуль можно представить как некоторый \quotes{ящик}, в который входит 2 провода с названиями \emph{\qeng{a}} и \emph{\qeng{b}} и из которого выходит один провод с названием \emph{\qeng{result}}. Внутри этого блока результат выполнения операции \quotes{И} (в синтаксисе Verilog записывается как \quotes{\&}) над входами соединяют с выходом.}
\par{Схемотично изобразим этот модуль:}

\begin{figure}[H]
  \centering
  \def\svgwidth{\columnwidth}
  \includesvg{pict_1_1}
  \caption{Структура модуля \qeng{and\_gate}}
\end{figure}

\par{Аналогично опишем все оставшиеся вентили:}

\noindent
\begin{minipage}{\linewidth}
  \lstinputlisting[caption={Модуль, описывающий вентиль \quotes{ИЛИ}}]{./code_examples/or_gate.v}
\end{minipage}

\noindent
\begin{minipage}{\linewidth}
  \lstinputlisting[caption={Модуль, описывающий вентиль \mbox{\quotes{Исключающее ИЛИ}}}]{./code_examples/xor_gate.v}
\end{minipage}

\noindent
\begin{minipage}{\linewidth}
  \lstinputlisting[caption={Модуль, описывающий вентиль \quotes{НЕ}}]{./code_examples/not_gate.v}
\end{minipage}

\par{В проектировании цифровых устройств логические вентили наиболее часто используются для формулировки и проверки сложных условий, например:}

\lstinputlisting[caption={Пример использования логических вентилей}]{./code_examples/logic_gatex_example.v}

\par{Условие будет выполняться либо когда \emph{не} выполнено условие \emph{\qeng{c}}, либо когда одновременно выполняются условия \emph{\qeng{a}} и \emph{\qeng{b}}. \emph{Здесь и далее под условием понимается логический сигнал, отражающий его истинность.}}
\par{В качестве входов, выходов и внутренних соединений в блоках могут использоваться шины — группы проводов. Ниже приведен пример работы с шинами:}

\lstinputlisting[caption={Модуль, описывающий побитовое \quotes{ИЛИ} \mbox{между двумя шинами}},float,floatplacement=H]{./code_examples/bus_or.v}

\par{Это описание описывает побитовое \quotes{ИЛИ} между двумя шинами по 8 бит. То есть описываются восемь логических вентилей \quotes{ИЛИ}, каждый из которых имеет на входе соответствующие разряды из шины \emph{\qeng{x}} и шины \emph{\qeng{y}}.}

\par{При использовании шин можно в описании использовать конкретные биты шины и группы битов. Для этого используют квадратные скобки после имени шины:}

\lstinputlisting[caption={Модуль, демонстрирующий \mbox{битовую адресацию шин}}, ]{./code_examples/bitwise_ops.v}

\par{Такому описанию соответствует следующая структурная схема, приведённая на Рис. \ref{fig:bitwiseops}}

\begin{figure}[H]
  \centering
  \def\svgwidth{\columnwidth}
  \includesvg{pict_1_2}
  \caption{Структура модуля \qeng{bitwise\_ops}}
  \label{fig:bitwiseops}
\end{figure}

\par{Впрочем, реализация ФАЛ с помощью логических вентилей не всегда представляется удобной. Допустим нам нужно описать таблично-заданную ФАЛ. Тогда описания этой функции при помощи логических вентилей нам придётся сначала минимизировать её и только после этого, получив логическое выражение (которое, несмотря на свою минимальность, не обязательно является коротким), сформулировать его с помощью языка \eng{Verilog HDL}. Как видно, ошибку легко допустить на любом из этих этапов.}

\par{Одно из главных достоинств \eng{Verilog HDL} — это возможность описывать поведение цифровых устройств вместо описания их структуры.}

\par{Программа-синтезатор анализирует синтаксические конструкции поведенческого описания цифрового устройства на \eng{Verilog HDL}, проводит оптимизацию и, в итоге, вырабатывает структуру, реализующую цифровое устройство, которое соответствует заданному поведению.}

\par{Используя эту возможность, опишем таблично-заданную ФАЛ на \eng{Verilog HDL}:}

\lstinputlisting[caption={Пример описания таблично-заданной ФАЛ на \eng{Verilog HDL}}, ]{./code_examples/function_example.v}

\par{Описание, приведённое выше, определяет $y$, как таблично-заданную функцию, которая равна нулю на наборах 0, 2, 5, 6, 7 и единице на всех остальных наборах.}

\par{Остановимся подробнее на новых синтаксических конструкциях:}
\par{Описание нашего модуля начинается с создания трёхбитной шины \qeng{x\_bus} на строке 7.}
\par{После создания шины \qeng{x\_bus}, на она подключается к объединению проводов \qeng{x2}, \qeng{x1} и \qeng{x0} с помощью оператора \eng{assign} как показано на Рис. \ref{fig:assign}.}

\begin{figure}[H]
  \centering
  \def\svgwidth{\columnwidth}
  \includesvg{assign}
  \caption{Действие оператора \kword{assign}}
  \label{fig:assign}
\end{figure}

\par{Затем начинается функциональный блок \kword{always}, на котором мы остановимся подробнее.}
\par{\eng{Verilog HDL} описывает цифровую аппаратуру, которая существует вся одновременно, но инструменты анализа и синтеза описаний являются программами и выполняются последовательно на компьютере. Так возникла необходимость последовательной программе «рассказать» про то, какие события приводят к срабатыванию тех или иных участков кода. Сами эти участки назвали процессами. Процессы обозначаются ключевым словом \kword{always}.}

\par{В скобках после символа @ указывается так называемый \emph{список чувствительности процесса}, т.е. те сигналы, изменение которых должно приводить к пересчёту результатов выолнения процесса.}

\par{Например, результат ФАЛ надо будет пересчитывать каждый раз, когда изменился входной вектор (любой бит входного вектора, т.е. любая переменная ФАЛ). Эти процессы можно назвать блоками, или частями будущего цифрового устройтсва.}

\par{Новое ключевое слово \kword{reg} здесь необходимо потому, что в выходной вектор происходит запись, а запись в языке \eng{Verilog HDL} разрешена только в «регистры» — специальные «переменные», предусмотренные в языке. Данная концепция и ключевое слово reg будет рассмотрено гораздо подробнее в следующей лабораторной работе.}

\par{Оператор \kword{<=} называется оператором \emph{неблокирующего присваивания}. В результате выполнения этого оператора то, что стоит справа от него, «помещается» («кладется», «перекладывается») в регистр, который записан слева от него. Операции неблокирующего присваивания происходят одновременно по всему процессу.}

\par{Оператор \kword{case} описывает выбор действия в зависимости от анализируемого значения. В нашем случае анализируется значение шины \qeng{x\_bus}. Ключевое слово \kword{default} используется для обозначения всех остальных (не перечисленных) вариантов значений.}

\par{Константы и значения в языке \eng{Verilog HDL} описываются следующим образом: сначала указывается количество бит, затем после апострофа с помощью буквы указывается формат и, сразу за ним, записывается значение числа в этом формате.}

\par{Возможные форматы:
  \begin{itemize}[noitemsep,topsep=0pt, after=\vspace{2pt}]
    \item b – бинарный, двоичный;
    \item h – шестнадцатеричный;
    \item d – десятичный.
  \end{itemize}}

\par{Немного расширив это описание, легко можно определить не одну, а сразу несколько ФАЛ одновременно. Для упрощения записи сразу объединим во входную шину все переменные. В выходную шину объединим значения функций:}

\lstinputlisting[caption={Описание дешифратора на языке \eng{Verilog HDL}}, ]{./code_examples/decoder.v}

\par{Теперь нам удалось компактно записать четыре функции, каждая от трёх переменных:
\begin{itemize}[noitemsep,topsep=2pt,label={}]
  \item $y_0=f(x_2,x_1,x_0);$
  \item $y_1=f(x_2,x_1,x_0);$
  \item $y_2=f(x_2,x_1,x_0);$
  \item $y_3=f(x_2,x_1,x_0).$
\end{itemize}}

\par{Но, если мы посмотрим на только что описанную конструкцию под другим углом, мы увидим, что это описание можно трактовать следующим образом: \quotes{поставить каждому возможному входному вектору $x$ в соответствие заранее определенный выходной вектор $y$}. Такое цифровое устройство называют \emph{дешифратором}.}

\par{На Рис. \ref{fig:decoder} показано принятое в цифровой схемотехнике обозначение дешифратора.}

\begin{figure}[H]
  \centering
  \def\svgwidth{\columnwidth}
  \includesvg{decoder}
  \caption{Графическое обозначение дешифратора}
  \label{fig:decoder}
\end{figure}

\par{Заметим, что длины векторов не обязательно должны совпадать, а единственным условием является полное покрытие всех возможных входных векторов, что, например, может достигаться использованием условия \kword{default} в операторе \kword{case}.}

\par{Дешифраторы активно применяются при разработке цифровых устройств. В большинстве цифровых устройств в явном или неявном виде можно встретить дешифратор.}

\par{Рассмотрим еще один интересный набор ФАЛ:}

\lstinputlisting[caption={Описание мультиплексора на языке \eng{Verilog HDL}}, ]{./code_examples/multiplexer.v}

\par{Что можно сказать об этом описании? Выходной вектор $y$ — это результат работы трёх ФАЛ, каждая из которых является функцией 6 переменных. Так, $y_0 = f(a_0, b_0, c_0, d_0, s_1, s_0)$.}

\par{Анализируя оператор \kword{case}, можно увидеть, что главную роль в вычислении значения ФАЛ играет вектор $s$, в результате проверки которого выходу ФАЛ присваивается значение \quotes{выбранной} переменной.}

\par{Получившееся устройство называется \emph{мультиплексор}}.

\par{Мультиплексор работает подобно коммутирующему ключу, замыкающему выход с выбранным входом. Для выбора входа мультиплексору нужен сигнал управления. }

\par{Графическое изображение мультиплексора приведено на Рис. \ref{fig:mux}}

\begin{figure}[H]
  \centering
  \def\svgwidth{\columnwidth}
  \includesvg{mux}
  \caption{Графическое обозначение мультиплексора}
  \label{fig:mux}
\end{figure}

\par{Особенно хочется отметить, что на самом деле никакой \quotes{проверки} сигнала управления не существует и уж тем более не существует \quotes{коммутации}, ведь мультиплексор — это таблично-заданная ФАЛ. Результат выполнения этой ФАЛ выглядит так, как будто происходит \quotes{подключение} \quotes{выбранной} входной шины к выходной.}

\par{Приведём для наглядности таблицу, задающую ФАЛ для одного бита выходного вектора (число ФАЛ в мультиплексоре и, следовательно, число таблиц, равняется числу бит в выходном векторе). Для краткости выпишем таблицу наборами строк вида: $f(s_1, s_0, a_0, b_0, c_0, d_0) = y_0$ в четыре столбца.}

\par{Обратите внимание, что в качестве старших двух бит входного вектора для удобства записи и анализа мы выбрали переменные \quotes{управляющего} сигнала, а выделение показывает какая переменная \quotes{поступает} на выход функции $f$:}

\begin{longtable}{ c c c c}

  $f(00\bm{0}000) = 0$ & 
  $f(010\bm{0}00) = 0$ & 
  $f(1000\bm{0}0) = 0$ & 
  $f(11000\bm{0}) = 0$ \\ 

  $f(00\bm{0}001) = 0$ & 
  $f(010\bm{0}01) = 0$ & 
  $f(1000\bm{0}1) = 0$ & 
  $f(11000\bm{1}) = 1$ \\ 

  $f(00\bm{0}010) = 0$ & 
  $f(010\bm{0}10) = 0$ & 
  $f(1000\bm{1}0) = 1$ & 
  $f(11001\bm{0}) = 0$ \\ 

  $f(00\bm{0}011) = 0$ & 
  $f(010\bm{0}11) = 0$ & 
  $f(1000\bm{1}1) = 1$ & 
  $f(11001\bm{1}) = 1$ \\ 

  $f(00\bm{0}100) = 0$ & 
  $f(010\bm{1}00) = 1$ & 
  $f(1001\bm{0}0) = 0$ & 
  $f(11010\bm{0}) = 0$ \\ 

  $f(00\bm{0}101) = 0$ & 
  $f(010\bm{1}01) = 1$ & 
  $f(1001\bm{0}1) = 0$ & 
  $f(11010\bm{1}) = 1$ \\ 

  $f(00\bm{0}110) = 0$ & 
  $f(010\bm{1}10) = 1$ & 
  $f(1001\bm{1}0) = 1$ & 
  $f(11011\bm{0}) = 0$ \\ 

  $f(00\bm{0}111) = 0$ & 
  $f(010\bm{1}11) = 1$ & 
  $f(1001\bm{1}1) = 1$ & 
  $f(11011\bm{1}) = 1$ \\ 

  $f(00\bm{1}000) = 1$ & 
  $f(011\bm{0}00) = 0$ & 
  $f(1010\bm{0}0) = 0$ & 
  $f(11100\bm{0}) = 0$ \\ 

  $f(00\bm{1}001) = 1$ & 
  $f(011\bm{0}01) = 0$ & 
  $f(1010\bm{0}1) = 0$ & 
  $f(11100\bm{1}) = 1$ \\ 

  $f(00\bm{1}010) = 1$ & 
  $f(011\bm{0}10) = 0$ & 
  $f(1010\bm{1}0) = 1$ & 
  $f(11101\bm{0}) = 0$ \\ 

  $f(00\bm{1}011) = 1$ & 
  $f(011\bm{0}11) = 0$ & 
  $f(1010\bm{1}1) = 1$ & 
  $f(11101\bm{1}) = 1$ \\ 

  $f(00\bm{1}100) = 1$ & 
  $f(011\bm{1}00) = 1$ & 
  $f(1011\bm{0}0) = 0$ & 
  $f(11110\bm{0}) = 0$ \\ 

  $f(00\bm{1}101) = 1$ & 
  $f(011\bm{1}01) = 1$ & 
  $f(1011\bm{0}1) = 0$ & 
  $f(11110\bm{1}) = 1$ \\ 

  $f(00\bm{1}110) = 1$ & 
  $f(011\bm{1}10) = 1$ & 
  $f(1011\bm{1}0) = 1$ & 
  $f(11111\bm{0}) = 0$ \\ 

  $f(00\bm{1}111) = 1$ & 
  $f(011\bm{1}11) = 1$ & 
  $f(1011\bm{1}1) = 1$ & 
  $f(11111\bm{1}) = 1$ \\ 
\end{longtable}

\section*{Пример задания лабораторной работы}
\par{Пример формируется...}


\chapter{Лабораторная работа №3\\Регистры и счётчики} 

\par{Функции цифровых устройств, естественно, не сводятся к реализации разнообразных ФАЛ. Нам хотелось бы использовать цифровые устройства для обработки информации, вычислений. Но для осуществления этих возможностей нам недостаёт элемента памяти, который мог бы хранить промежуточные результаты. Ведь невозможно сделать калькулятор, если нет возможности сохранить вводимые числа и результат вычисления.}

\par{Элемент памяти — один из самых важных элементов цифровых устройств. Чтобы не делать ошибок при разработке цифровых устройств, необходимо понять место этого узла, его идею и инструменты языка \eng{Verilog}, связанные с ним.}

\par{Первый элемент памяти, который мы рассмотрим — это  \textbf{защелка} (англ. \eng{latch})}

\par{Защелка является основой всех элементов памяти. Она состоит из двух элементов И-НЕ (или из двух элементов ИЛИ-НЕ, в зависимости от базиса, выбранного при проектировании), соединенных по следующей схеме:}

\begin{figure}[H]
	\centering
	\def\svgwidth{\columnwidth}
	\includesvg{RS_latch}
	\caption{Структура \eng{RS}-защелки}
\end{figure}

\par{У защелки два входа и два выхода. Входами являются сигналы \quotes{сброс} и \quotes{установка в единицу} или по-английски \quotes{reset} и \quotes{set}. В зависимости от элементов, из которых состоит защелка, полярность входных сигналов будет меняться. В базисе И-НЕ сброс и установка происходят, когда соответственно сигналы \eng{R} или \eng{S} находятся в нуле, поэтому их обозначают как \quotes{не-сброс} и \quotes{не-установка}, чтобы отразить этот факт. Выход защелки — это тот бит данных, который она хранит. Два выхода отличаются полярностью — один из них инвертирует хранимый бит. Ниже приведена таблица со всеми возможными комбинациями входных сигналов и временная диаграмма работы защелки.}

%\begin{figure}[H]
%\begin{tikztimingtable}[
%    timing/dslope=0.1,
%    timing/.style={x=5ex,y=2ex},
%    x=5ex,
%    timing/rowdist=3ex,
%    timing/name/.style={font=\sffamily\scriptsize},
%]
%\draw [<->,thick] (0,4) node (yaxis) [above] {$y$}
%        |- (5,0) node (xaxis) [right] {$x$};
%  
%  S    & 1L 4H \\
%  R    & 3H 2L \\
%  Q    & 3H 2L \\
%  
%\extracode
%\begin{pgfonlayer}{background}
%\begin{scope}[semitransparent ,semithick,anchor=south,align=center]
%\vertlines[darkgray,dotted]{0.5,1.5 ,...,8.0}
%	node at (0, 0) {Установка в \quotes{1}};
%	node at (2, 0) {Хранение};
%	node at (4, 0) {Сброс в \quotes{0}};


\begin{figure}[H]
\centering
\begin{tikztimingtable}[%
    timing/dslope=0.1,
    timing/.style={x=5ex,y=2ex},
    very thick,
    x=5ex,
    timing/rowdist=5ex, %расстояние между линиями
    timing/name/.style={font=\sffamily\scriptsize},
]

	S    & 1L 4H \\
	R    & 3H 2L \\
	Q    & 3H 2L \\
\extracode
\begin{pgfonlayer}{background}
\begin{scope}[semitransparent ,semithick]
\vertlines[darkgray,dotted]{1,3} %точки на фоне
\end{scope}
\end{pgfonlayer}
\draw[->,thin] (0,0) -- (5.05,0);
\draw[->,thin] (0,-3.1) -- (5.05,-3.1);
\draw[->,thin] (0,-6.2) -- (5.05,-6.2);
\end{tikztimingtable}
\caption{Временная диаграмма работы \eng{RS}-защелки}
\end{figure}







\par{Опишем защелку на языке \eng{Verilog}, опираясь на её структуру, которую мы рассмотрели выше. Нам понадобятся два входа, два выхода и два элемента И-НЕ, которые мы опишем с помощью операций И (оператор \&) и НЕ (оператор \textasciitilde).}

\lstinputlisting[caption={Описание \eng{RS}-защелки на языке \eng{Verilog HDL}}, ]{./code_examples/rs_latch.v}
		
\par{Элемент памяти нам, прежде всего, нужен для хранения данных. Для того, чтобы защелкой стало удобнее пользоваться, немного изменим схему подключения управляющих сигналов.}

\begin{figure}[H]
	\centering
	\def\svgwidth{\columnwidth}
	\includesvg{D_latch}
	\caption{Структура \eng{D}-защелки}
\end{figure}
		
\par{Защелка теперь будет работать следующим образом: при высоком уровне на входе \quotes{разрешить работу} (\qeng{enable}) данные со входа \quotes{данные} (\qeng{data}) будут проходить через защелку на выход, при низком уровне на входе \quotes{разрешить работу} защелка будет сохранять на выходе последнее значение со входа \quotes{данные}, которое было до переключения сигнала \quotes{разрешить работу}. Работа такой защелки показана на временной диаграмме ниже.}
		
\par{Как мы уже говорили, использовать структурные описания не всегда удобно. В большинстве случаев использовать поведенческое описание намного эффективнее. Поведенческое описание часто формулируется гораздо лаконичнее, и, так как его легче понять человеку, улучшается читаемость кода и уменьшается вероятность ошибок при его написании.}

\lstinputlisting[caption={Поведенческое описание \eng{D}-защелки на языке \eng{Verilog HDL}}, ]{./code_examples/d_latch.v}
		
\par{Если добавить к этой схеме еще две защелки, то можно привязать изменение \quotes{содержимого} защелки к переходу управляющего сигнала из \quotes{0} в \quotes{1}, то получим следующую структуру:}

\begin{figure}[H]
	\centering
	\def\svgwidth{\columnwidth}
	\includesvg{dff_struct}
	\caption{Структура \eng{D}-триггера}
\end{figure}
		
\par{Эту схему можно немного доработать, введя управляющие сигналы сброса, установки в единицу и разрешения работы. Упрощенно такая схема изображается следующим образом.}

\begin{figure}[H]
	\centering
	\def\svgwidth{\columnwidth}
	\includesvg{dff}
	\caption{Графическое обозначение \eng{D}-триггера}
\end{figure}
		
\par{Эта схема получила широчайшее применение в цифровой схемотехнике и называется \eng{d}-триггер (от слова \qeng{data} — данные). Ниже приведена временная диаграмма работы \eng{d}-триггера.}
		
\par{Заметим, что сигнал \eng{C} называют \quotes{тактирующим} сигналом или \quotes{сигналом синхронизации}. Обычно в роли этого сигнала выступает сигнал от внешнего источника (чаще всего кварцевого резонатора) со стабильной частотой. А сами цифровые устройства, для работы которых необходим сигнал синхронизации, называют синхронными.}

\par{Сигнал синхронизации играет очень большую роль в цифровых устройствах. Прежде всего, он необходим для того, чтобы избежать непредсказуемого и нестабильного поведения триггеров в цифровых устройствах.}

\lstinputlisting[caption={Описание \eng{D}-триггера на языке \eng{Verilog HDL}}, ]{./code_examples/d_flipflop.v}
		
\par{В описании появилось новое ключевое слово \eng{posedge}. Оно используется только в списке чувствительности блока \eng{always} и означает событие перехода сигнала, имя которого стоит после этого ключевого слова, из состояния \quotes{0} в состояние \quotes{1}.}
		
		
\par{Ключевое слово \eng{posedge} было введено прежде всего для того, чтобы описывать схемы, содержащие триггеры. Ведь триггеры, как мы уже говорили, могут менять своё состояние только в момент положительного фронта (англ. \eng{positive edge}) сигнала синхронизации.}
		
		
\par{Добавление в список чувствительности события \eng{posedge rst} позволяет описать поведение триггера в момент асинхронного сброса: как только случается переход \eng{rst} из \quotes{0} в \quotes{1} срабатывает блок \eng{always} и проверка условия \kword{if} (\eng{rst}) дает положительный результат, триггер сбрасывается в \quotes{0}.}

\par{}

\par{Если объединить несколько триггеров в группу, то получится то, что в цифровой схемотехнике называют \quotes{регистр}.}

\lstinputlisting[caption={Описание регистра на языке \eng{Verilog HDL}}, ]{./code_examples/register.v}
		
\par{Элементы памяти позволяют нам сохранять информацию для дальнейшей обработки или хранить готовый результат вычисления, хранить промежуточные результаты.}

\par{Запомните описание регистра. Оно используется при проектировании практически любого цифрового устройства с помощью \eng{Verilog}.}	

\par{Необходимо отметить важную концепцию языка \eng{Verilog}. \textbf{Переменные типа \eng{reg} могут быть изменены только в пределах одного блока \eng{always}. Переменные доступны для проверки в любом из блоков, но изменять их значение можно только в одном из них.}}	

\lstinputlisting[caption={Пример присвоения значения переменной а разных блоках \eng{always} на языке \eng{Verilog HDL}}, ]{./code_examples/error_example_2.v}

\par{Одной из простейших, и в тоже время широко распространённой, цифровой схемой на основе регистров является счётчик.}

\par{Счётчик считает количество тактов, которое прошло с момента его обнуления.}
		
\par{Такая простая схема, тем не менее, используется практически в каждом цифровом устройстве. Как будет показано дальше, счётчик легко можно доработать таким образом, чтобы отсчитывались не такты, а какие-то события. Например, событиями могут быть: нажатие кнопки, принятие пакета данных, срабатывание датчика, выполнение какого-то условия (периодическое) и другое.}		

\par{}

\par{Итак, для того чтобы реализовать счетчик нам понадобится регистр и сумматор. Причем сумматор будет складывать значение, хранящееся в регистре с константой (в нашем случае единицей) а результат сложения будет поступать на вход регистра.}		
		
\par{}

\par{В результате получим следующую схему:}

\begin{figure}[H]
	\centering
	\def\svgwidth{\columnwidth}
	\includesvg{counter}
	\caption{Структура восьмибитного счетчика}
\end{figure}
		
\par{На временной диаграмме ниже хорошо видно как работает счётчик:}
		
\par{Опишем поведение такого счётчика на \eng{Verilog}.}

\lstinputlisting[caption={Описание восьмиитного счетчика на языке \eng{Verilog HDL}}, ]{./code_examples/counter_8bit.v}
		
\par{Для того чтобы можно было подсчитывать события, а не переходы сигнала синхронизации из \quotes{0} в \quotes{1} понадобится ввести еще одну схему. Её смысл и назначение заключается в следующем: нам необходимо из асинхронного события получить синхронный сигнал единичной длительности. Тогда, подавая такой сигнал на вход \eng{enable} счётчика, мы сможем считать количество произошедших событий.}
		
\par{Ниже представлена схема, позволяющая сделать это:}

\begin{figure}[H]
	\centering
	\def\svgwidth{\columnwidth}
	\includesvg{register_2}
	\caption{Структура регистра на \eng{D}-триггерах}
\end{figure}
		
\par{Пример работы такой схемы:}

\par{Естественно такая схема работает только тогда, когда входной сигнал изменяется с частотой меньшей, чем частота синхронизации.}

\par{Сигнал eng{out} в таком случае подключается к входу \eng{enable} счётчика.}		
		
\section{Задание лабораторной работы}

\par{Описать на языке \eng{Verilog} цифровое устройство, функционирующее согласно следующим принципам:
\begin{enumerate}[noitemsep,topsep=0pt, after=\vspace{2pt}]
  \item Ввод информации происходит с переключателей \eng{SW}[9:0] и кнопок \eng{KEY}[0], \eng{KEY}[1]. Внешний источник сигнала синхронизации: \eng{CLK}50;
  \item \eng{KEY}[1] должна функционировать как общий асинхронный сброс устройства;
  \item При нажатии на \eng{KEY}[0] записывать данные с \eng{SW}[9:0] в десятиразрядный регистр;
  \item Содержимое десятиразрядного регистра выводить на \eng{LEDR}[9:0];
  \item При нажатии на \eng{KEY}[0] увеличивать 8-ми разрядный счётчик нажатий на 1, если произошло событие, указанное в индивидуальном задании студента;
  \item Содержимое счётчика выводить в шестнадцатеричной форме на \eng{HEX}0 и \eng{HEX}1 (цифры с 0 до 9 и буквы \eng{A}, \eng{B}, \eng{C}, \eng{D}, \eng{E}, \eng{F})
\end{enumerate}}
		
\par{Выполнив описание модуля на языке \eng{Verilog} необходимо построить временные диаграммы его работы с помощью САПР \eng{Altera Quartus}.}		
		
\par{Привязать входы модуля к переключателям \eng{SW}, отладочной платы, а выход к шине \eng{HEX}0[6:0], получить прошивку для ПЛИС и продемонстрировать её работу.}
		
\section{Пример индивидуального задания}

\par{Событием является наличие 3 и более единиц на SW[9:0] в момент записи в регистр.}

\lstinputlisting[caption={Решение индивидуального задания (фрагмент кода лабораторной работы)}, ]{./code_examples/task_solution_2.v}
		
\section{Вопросы к защите лабораторной работы}

\begin{enumerate}[noitemsep,topsep=0pt, after=\vspace{2pt}]
  \item Какие элементы памяти вы изучили в данной лабораторной работе?
  \item Чем отличается \eng{RS}-защелка от \eng{D}-защелки?
  \item Какие входы могут быть у триггера? Перечислите все и назовите их функции.
  \item Какие блоки вашего цифрового устройства синхронные? Какие нет? Почему?
  \item Какой фрагмент вашего кода описывает вывод значения счетчика на семи сегментный индикатор? Как называется эта цифровая схема?
  \item Продемонстрируйте код реализующий индивидуальное задание.
  \item Покажите в коде лабораторной код счётчика.
  \item Что такое сигнал синхронизации?
\end{enumerate}





\chapter{Лабораторная работа №6\\\eng{FLASH} память} 

\section{Виды энергонезависимой памяти}

\par{Ни один из блоков цифровых устройств, которые мы рассмотрели ранее не способен хранить информацию при отсутствии питания.}

\par{Чтобы решить эту проблему, на заре вычислительной техники, данные в цифровое устройство после подачи питания загружали с таких носителей, как перфокарты и, позже, магнитные ленты. Ещё позже для целей хранения информации при отсутствии питания были разработаны накопители на гибких магнитных дисках --- дискетах и жёстких магнитных дисках --- \qeng{HDD}. На данный момент для хранения данных при отсутствии питания наиболее широко применяется \eng{FLASH}-память.}

\par{Энергонезависимые накопители информации обладают как преимуществами, так и недостатками по сравнению с энергозависимой \eng{RAM}-памяти.} 

\par{Как правило, энергонезависимая память существенно уступает по скорости работы \eng{RAM}-памяти. Это ограничение удалось преодолеть только недавно: в 2016 году была представлена постоянная память, где информация хранится в виде спина электрона. Такая память по скорости работы не уступает современной \eng{RAM}-памяти, такой как \eng{DDR5}. Но подобная память ещё долгое время будет оставаться недоступной для рядового пользователя из-за высокой стоимости и малой степени освоения технологии серийного производства 10нм.}

\section{Принципы работы \eng{FLASH}-памяти}

\par{В качестве элемента хранения информации \eng{FLASH}-память использует транзистор с плавающим затвором, где состояние затвора определяет бит хранимой информации, изображённый на Рис.\ref{fig:flash_memory_cell}}

% \begin{figure}[H]
% \centering
% \def\svgwidth{\columnwidth}
% \includesvg{flash_memory_cell}
% \caption{Ячейка \eng{FLASH}-памяти}
% \label{fig:flash_memory_cell}
% \end{figure}

\par{Рассмотрим работу такого транзистора.}

\par{Как вы видите, он содержит два затвора: управляющий и плавающий. Плавающий полностью находится в диэлектрике и при этом способен накапливать электроны. От величины накопленного заряда меняется \quotes{лёгкость} с которой транзистор открывается --- т.е. величина напряжения \quotes{управляющий затвор---исток}, при которой через транзистор начнёт течь ток.}

\par{Для хранения информации используют следующий принцип (см.Рис.\ref{fig:flash_cell_read}): чтобы считать информацию, на управляющий затвор подаётся напряжение чтения --- среднее между самым сильным (в диэлектрике нет электронов) и самым слабым (в диэлектрике максимум электронов). Если транзистор открывается, значит в плавающем затворе были электроны и мы считаем, что в нём записан \quotes{0}, если не открывается, значит электронов в плавающем затворе нет и записана \quotes{1}.}

% \begin{figure}[H]
% \centering
% \def\svgwidth{\columnwidth}
% \includesvg{flash_cell_read}
% \caption{Чтение из ячейки \eng{FLASH}-памяти}
% \label{fig:flash_cell_read}
% \end{figure}

\par{Осталось понять как можно \quotes{заставить} электроны попадать в плавающий затвор, ведь он изолирован диэлектриком. Не вдаваясь в подробности скажем, что если подать достаточно высокое напряжение \quotes{управляющий затвор---сток}, то у электронов хватит энергии, чтобы \quotes{перескочить} диэлектрик и попасть в плавающий затвор. А если изменить полярность этого напряжения, то можно заставить электроны покинуть плавающий затвор (см.Рис.\ref{fig:flash_cell_write}).}

% \begin{figure}[H]
% \centering
% \def\svgwidth{\columnwidth}
% \includesvg{flash_cell_write}
% \caption{Запись в ячейку \eng{FLASH}-памяти}
% \label{fig:flash_cell_write}
% \end{figure}

\par{Самое важное в этой идее то, что если электроны попали в плавающий затвор они не могут самостоятельно покинуть его через диэлектрик и будут оставаться там в течении многих лет. Таким образом и достигается сохранение записанной информации при отсутствии питания.}

\par{Теперь мы знаем, что для того чтобы записать или считать информацию из \eng{FLASH}-памяти надо использовать большую разность потенциалов. Но на самом деле транзистор устроен таким образом, что энергия, необходимая чтобы \quotes{загнать} электроны в плавающий затвор меньше энергии, необходимой, чтобы их \quotes{выгнать}. Это делается чтобы при чтении значения электроны не покидали плавающий затвор.}

\par{При такой организации становится сложно обеспечить очистку каждого транзистора в отдельности, поэтому обычно стирается целая группа ячеек.}

\par{Из-за особенностей транзистора с плавающим затвором, которые мы рассмотрели можно выделить следующие характерные черты \eng{FLASH}-памяти:
\begin{itemize}
  \item Запись значения возможна только из логической \quotes{1} в логический \quotes{0};
  \item Удаление информации возможно только из группы ячеек одновременно (блока);
  \item Удаление и запись информации приводят к деградации ячеек памяти;
  \item Чтение также приводит к деградации ячеек памяти, но в меньшей степени.
\end{itemize}}

\par{На Рисунке\ref{fig:flash_structure} изображена общая структура \eng{FLASH}-памяти. Как видно она практически не отличается от \eng{RAM}-памяти: из ячеек строится матрица, контролируемая управляющим блоком. А сам управляющий блок обеспечивает коммуникацию с внешними устройствами, дешифрацию адреса и управление записью и чтением массива элементов памяти. Подключение \eng{FLASH}-памяти и управление ей со стороны цифрового устройства полностью зависит от того, как реализован блок управления --- доступ к содержимому \eng{FLASH}-памяти может быть синхронный или асинхронный, по последовательной или параллельной шине, с разделением шин адреса и данных или без него.}

% \begin{figure}[H]
% \centering
% \def\svgwidth{\columnwidth}
% \includesvg{flash_structure}
% \caption{Ячейка \eng{FLASH}-памяти}
% \label{fig:flash_structure}
% \end{figure}

\section{Чип \eng{FLASH}-памяти \eng{S29AL032D}}

\par{Для практического знакомства с \eng{FLASH}-памятью мы спроектируем контроллер микросхемы \eng{S29AL032D}. Именно эта микросхема установлена на отладочной плате Altera DE1.}
\par{Основным источником информации о любой микросхеме служат технические условия (англ. \eng{datasheet}). В большинстве случаев в этом документе содержатся все необходимые сведения для использования микросхемы: электрические параметры, размеры и тип корпуса, информация о выводах, и многие другие сведения. В том числе \eng{datasheet} содержит данные о протоколах информационного обмена.}
\par{В нашем случае микросхема уже подключена, поэтому из всего \eng{datasheet} нас прежде всего интересует каким образом необходимо взаимодействовать с данной микросхемой, чтобы записать или считать данные.}
\par{Для разработки контроллера следует ознакомиться со следующими разделами документа:
\begin{itemize}[noitemsep,label={}]
  \item 11. \eng{Commands Definitions};
  \item 12. \eng{Write Operation Status};
  \item 17. \eng{AC Characteristics}.
\end{itemize}}
\par{Далее будут приведены необходимые выдержки из документа, однако настоятельно рекомендуем ознакомиться с ним.}

\subsection{Операция чтения}
\par{Для чтения данных из чипа \eng{S29AL032D} не требуется никакой дополнительной подготовки. Временная диаграмма чтения приведена в пункте 17.2 \eng{datasheet} и представлена на Рис.\ref{fig:flash_read_wave}}

% \begin{figure}[H]
% \centering
% \def\svgwidth{\columnwidth}
% \includesvg{flash_read_wave}
% \caption{Временная диаграмма чтения \eng{S29AL032D}}
% \label{fig:flash_read_wave}
% \end{figure}

\par{Времена, указанные на диаграмме, приведены в Табл. \ref{table:flash_read_timings}}

% \tabcolsep=0.11cm
\begin{table}[htbp]
  \centering
  \small
  \begin{tabular}{l|l|c|c}
    Обозн. & Описание & Min & Max \\
    \hline
    $t_{RC}$ & Продолжительность цикла чтения & 70нс & 90нс\\
    $t_{ACC}$ & Задержка Адрес --- Данные & 70нс & 90нс\\
    $t_{CE}$ & Задержка Выбор Чипа --- Данные & 70нс & 90нс\\
  \end{tabular}
  \caption{Временные характеристики операции чтения \eng{S29AL032D}}
  \label{table:flash_read_timings}
\end{table}

\par{Как мы уже знаем, единственным источником информации о времени для цифрового устройства может являться только сигнал синхронизации, заранее известной частоты. Привяжем времена, упомянутые в Таблице \ref{table:flash_read_timings} к тактовому сигналу частоты 50 МГц. Полученная временная диаграмма показана на Рис. \ref{figure:clocked_flash_read}}

\begin{figure}[H]
\begin{tikztimingtable}[%
    timing/dslope=0.1,
    timing/.style={x=5ex,y=2ex},
    x=5ex,
    timing/rowdist=3ex,
    timing/name/.style={font=\sffamily\scriptsize},
]
  CLK50        & 18{c} \\
  ADDRESS      & 2u 4D{Read\ Addr.} 2u \\
  \nsig{CE}    & 2H 4L 4H \\
  \nsig{OE}    & 3H 3L 4H \\
  \nsig{WE}    & 1L 5H 4L \\
  \nsig{RESET} & 10H \\
  DATA         & 4Z 2D{Output\ Data} 2Z \\
  RY/\nsig{BY} & 10H \\
\extracode
\begin{pgfonlayer}{background}
\begin{scope}[semitransparent ,semithick]
\vertlines[darkgray,dotted]{0.5,1.5 ,...,8.0}
\end{scope}
\end{pgfonlayer}
\end{tikztimingtable}
\caption{Временная диаграмма операции чтения шины \eng{PCI}}
\end{figure}

\subsection{Операция записи}
\subsection{Операция очистки сектора}
\subsection{Проектирование контроллера \eng{S29AL032D}}

\end{document}