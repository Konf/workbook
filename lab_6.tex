\chapter{Лабораторная работа №6\\\eng{FLASH} память} 

\section{Виды энергонезависимой памяти}

\par{Ни один из блоков цифровых устройств, которые мы рассмотрели ранее не способен хранить информацию при отсутствии питания.}

\par{Чтобы решить эту проблему, на заре вычислительной техники, данные в цифровое устройство после подачи питания загружали с таких носителей, как перфокарты и, позже, магнитные ленты. Ещё позже для этих целей были разработаны накопители на гибких магнитных дисках --- дискетах и жёстких магнитных дисках --- \qeng{HDD}. На данный момент для хранения данных при отсутствии питания наиболее широко применяется \eng{FLASH}-память.}

\par{Энергонезависимые накопители информации обладают как преимуществами, так и недостатками по сравнению с энергозависимой \eng{RAM}-памятью.} 

\par{Как правило, энергонезависимая память существенно уступает по скорости работы \eng{RAM}-памяти. Это ограничение удалось преодолеть только недавно: в 2016 году была представлена постоянная память, где информация хранится в виде спина электрона. Такая память по скорости работы не уступает современной \eng{RAM}-памяти, такой как \eng{DDR5}. Но подобная память ещё долгое время будет  недоступна для рядового пользователя из-за высокой стоимости.}

\section{Принципы работы \eng{FLASH}-памяти}

\par{В качестве элемента хранения информации \eng{FLASH}-память использует транзистор с плавающим затвором. Состояние затвора определяет бит хранимой информации.}

% \begin{figure}[H]
% \centering
% \def\svgwidth{\columnwidth}
% \includesvg{flash_memory_cell}
% \caption{Ячейка \eng{FLASH}-памяти}
% \label{fig:flash_memory_cell}
% \end{figure}

\par{На Рис.\ref{fig:flash_memory_cell} схематично изображена структура такого транзистора.}

\par{Как вы видите, он содержит два затвора: управляющий и плавающий. Плавающий затвор --- это полупроводника, который полностью окружён диэлектриком. При этом плавающий затвор способен накапливать электроны. От величины накопленного заряда меняется \quotes{лёгкость} с которой транзистор открывается --- т.е. величина напряжения \quotes{управляющий затвор---исток}, при котором через транзистор начнёт течь ток. Чем больше электронов находятся в плавающем затворе, тем \quotes{легче} открывается транзистор --- ток начинает протекать через него при меньшем напряжении \quotes{управляющий затвор---исток}.}

\par{Для хранения информации используют следующий принцип (см. Рис.\ref{fig:flash_cell_read}): чтобы считать информацию, на управляющий затвор подаётся напряжение чтения --- среднее между самым сильным и самым слабым напряжением, способным открыть затвор. Если транзистор открывается, значит в плавающем затворе были электроны и мы считаем, что в нём записано значение \quotes{0}, если не открывается, значит электронов в плавающем затворе нет и записано значение \quotes{1}.}

% \begin{figure}[H]
% \centering
% \def\svgwidth{\columnwidth}
% \includesvg{flash_cell_read}
% \caption{Чтение из ячейки \eng{FLASH}-памяти}
% \label{fig:flash_cell_read}
% \end{figure}

\par{Осталось понять как можно \quotes{заставить} электроны попадать в плавающий затвор, ведь он изолирован диэлектриком. Не вдаваясь в подробности скажем, что если подать достаточно высокое напряжение \quotes{управляющий затвор---сток}, то у электронов хватит энергии, чтобы \quotes{перескочить} диэлектрик и попасть в плавающий затвор. А если изменить полярность этого напряжения, то можно \quotes{выгнать} электроны наружу (см. Рис.\ref{fig:flash_cell_write}).}

% \begin{figure}[H]
% \centering
% \def\svgwidth{\columnwidth}
% \includesvg{flash_cell_write}
% \caption{Запись в ячейку \eng{FLASH}-памяти}
% \label{fig:flash_cell_write}
% \end{figure}

\par{Самое важное в этой идее то, что если электроны попали в плавающий затвор они не могут самостоятельно покинуть его через диэлектрик и будут оставаться там в течении многих лет. Таким образом и достигается сохранение записанной информации при отсутствии питания.}

\par{Теперь мы знаем, что для того чтобы записать или считать информацию из \eng{FLASH}-памяти надо использовать большую разность потенциалов. Но на самом деле транзистор устроен таким образом, что энергия, необходимая чтобы \quotes{загнать} электроны в плавающий затвор меньше энергии, необходимой, чтобы их \quotes{выгнать}. Это делается чтобы при чтении значения электроны не покидали плавающий затвор.}

\par{При такой организации становится сложно обеспечить очистку каждого транзистора в отдельности, поэтому обычно стирается целая группа ячеек.}

\section{Особенности \eng{FLASH}-памяти}

\par{Из-за особенностей транзистора с плавающим затвором, которые мы рассмотрели можно выделить следующие характерные черты \eng{FLASH}-памяти:
\begin{itemize}
  \item Запись значения возможна только из логической \quotes{1} в логический \quotes{0};
  \item Удаление информации возможно только из группы ячеек одновременно (блока);
  \item Удаление и запись информации приводят к деградации ячеек памяти;
  \item Чтение также приводит к деградации ячеек памяти, но в меньшей степени.
\end{itemize}}

\section{Структура \eng{FLASH}-памяти}

\par{На Рисунке\ref{fig:flash_structure} изображена общая структура \eng{FLASH}-памяти. Как видно она практически не отличается от \eng{RAM}-памяти: из ячеек строится матрица, контролируемая управляющим блоком. А сам управляющий блок обеспечивает коммуникацию с внешними устройствами, дешифрацию адреса и управление записью и чтением массива элементов памяти. Подключение \eng{FLASH}-памяти и управление ей со стороны цифрового устройства полностью зависит от того, как реализован блок управления --- доступ к содержимому \eng{FLASH}-памяти может быть синхронный или асинхронный, по последовательной или параллельной шине, с разделением шин адреса и данных или без него.}

% \begin{figure}[H]
% \centering
% \def\svgwidth{\columnwidth}
% \includesvg{flash_structure}
% \caption{Ячейка \eng{FLASH}-памяти}
% \label{fig:flash_structure}
% \end{figure}

\section{Чип \eng{FLASH}-памяти \eng{S29AL032D}}

\par{Для практического знакомства с \eng{FLASH}-памятью мы спроектируем контроллер микросхемы \eng{S29AL032D}. Именно эта микросхема установлена на отладочной плате Altera DE1.}
\par{Основным источником информации о любой микросхеме служат технические условия (англ. \eng{datasheet}). В большинстве случаев в этом документе содержатся все необходимые сведения для использования микросхемы: электрические параметры, размеры и тип корпуса, информация о выводах, и многие другие сведения. В том числе \eng{datasheet} содержит данные о протоколах информационного обмена.}
\par{В нашем случае микросхема уже подключена, поэтому из всего \eng{datasheet} нас, в первую очередь, интересует каким образом необходимо взаимодействовать с этой микросхемой, чтобы записать или считать данные.}
\par{Для разработки контроллера следует ознакомиться со следующими разделами документа:
\begin{itemize}[noitemsep,label={}]
  \item 11. \eng{Commands Definitions};
  \item 12. \eng{Write Operation Status};
  \item 17. \eng{AC Characteristics}.
\end{itemize}}
\par{Далее будут приведены необходимые выдержки из документа, однако настоятельно рекомендуем ознакомиться с ним.}

\subsection{Проектирование контроллера \eng{S29AL032D}}
\par{Как мы уже знаем, контроллер предназначен для обмена информацией с внешними цифровыми устройствами. Он должен предоставлять удобный, простой интерфейс и обеспечивать все необходимые взаимодействия с устройством. В таком случае другие блоки могут использовать один и тот же контроллер.} 
\par{Чтобы начать разработку контроллера, нужно ответить важные вопросы: как должен работать наш контроллер и как он должен управляться?}
\par{Если мы хотим работать с памятью, то для нас наиболее важными являются операции записи и чтения данных.  Тогда наиболее удобным для нас был бы уже знакомый интерфейс, похожий на \eng{RAM}-память: данные для записи, данные для чтения, адрес и управляющие сигналы.}
\par{Теперь, когда мы определились с тем, как мы будем управлять контроллером, нам нужно понять как он должен взаимодействовать с самой микросхемой \eng{flash}-памяти. Для этого изучим операции записи и чтения, описанные в \eng{datasheet S29AL032D}}

\subsection{Операция чтения}
\par{Чтение данных из микросхемы \eng{S29AL032D} не требует никакой дополнительной подготовки. Временная диаграмма чтения приведена в пункте 17.2 \eng{datasheet} и представлена на Рис.\ref{fig:flash_read_wave}}

% \begin{figure}[H]
% \centering
% \def\svgwidth{\columnwidth}
% \includesvg{flash_read_wave}
% \caption{Временная диаграмма чтения \eng{S29AL032D}}
% \label{fig:flash_read_wave}
% \end{figure}

\par{Времена, указанные на диаграмме, приведены в Табл. \ref{table:flash_read_timings}}

% \tabcolsep=0.11cm
\begin{table}[htbp]
  \centering
  \small
  \begin{tabular}{l|l|c|c}
    Обозн. & Описание & Min & Max \\
    \hline
    $t_{RC}$ & Продолжительность цикла чтения & 70нс & 90нс\\
    $t_{ACC}$ & Задержка Адрес --- Данные & 70нс & 90нс\\
    $t_{CE}$ & Задержка Выбор Чипа --- Данные & 70нс & 90нс\\
  \end{tabular}
  \caption{Временные характеристики операции чтения \eng{S29AL032D}}
  \label{table:flash_read_timings}
\end{table}

\par{Чтобы выполнить операцию чтения, нам нужно повторить эту временную диаграмму и соблюсти все временные интервалы. Но как это сделать?}

\par{Каким образом можно выдержать указанные временные интервалы?}
\par{Мы уже знаем, что единственным источником информации о времени для цифрового устройства может являться только сигнал синхронизации, частота которого заранее известна.}
\par{Привяжем времена, упомянутые в Таблице \ref{table:flash_read_timings} к тактовому сигналу частоты 50 МГц, которым тактируется устройство. При этом учтём, что некоторые задержки могут быть равны нулю.}
\par{Полученная временная диаграмма показана на Рис. \ref{figure:clocked_flash_read}}

\begin{figure}[H]
\begin{tikztimingtable}[%
    timing/dslope=0.1,
    timing/.style={x=5ex,y=2ex},
    x=5ex,
    timing/rowdist=3ex,
    timing/name/.style={font=\sffamily\scriptsize},
]
  CLK50        & 18{c} \\
  ADDRESS      & 2u 4D{Read\ Addr.} 2u \\
  \nsig{CE}    & 2H 4L 4H \\
  \nsig{OE}    & 3H 3L 4H \\
  \nsig{WE}    & 1L 5H 4L \\
  \nsig{RESET} & 10H \\
  DATA         & 4Z 2D{Output\ Data} 2Z \\
  RY/\nsig{BY} & 10H \\
\extracode
\begin{pgfonlayer}{background}
\begin{scope}[semitransparent ,semithick]
\vertlines[darkgray,dotted]{0.5,1.5 ,...,8.0}
\end{scope}
\end{pgfonlayer}
\end{tikztimingtable}
\caption{Временная диаграмма операции чтения шины \eng{PCI}}
\end{figure}

\subsection{Операция записи}
\par{Обычно запись во \eng{flash}-память --- более сложная операция, чем чтение. Многие производители используют для записи специальные последовательности команд, защищая таким образом память от случайной записи.}
\par{Согласно \eng{datasheet S29AL032D} (разделы 7 и 11) для того, чтобы осуществить запись, необходимо выполнить следующую последовательность из 4-х операций:
\begin{itemize}[noitemsep, label={}]
  \item Записать данные \eng{AA} по адресу \eng{AAA};
  \item Записать данные \eng{55} по адресу \eng{555};
  \item Записать данные \eng{A0} по адресу \eng{AAA};
  \item Записать нужные данные по указанному адресу.
\end{itemize}
}
\par{Также согласно \eng{datasheet}, данные записываются не мгновенно. На то, чтобы провести операцию записи одного слова требуется порядка 11 мкс. Что приблизительно соответствует 550 тактам на частоте 50 МГц.}
\par{Также крайне важно, что при записи данных микросхема \eng{S29AL032D} может менять значение с \quotes{1} на \quotes{0}.}
\par{Чтобы поменять значение с \quotes{0} на \quotes{1} требуется очистка целого фрагмента памяти, называемого сектором, либо полная очистка всей микросхемы!}
\par{Значит, для того, чтобы мы могли полноценно пользоваться микросхемой \eng{S29AL032D} нам потребуется реализовать в контроллере функции очистки.}

\subsection{Операция очистки}
\par{Для очистки выбранного сектора необходимо выполнить следующую последовательность операций:
\begin{itemize}[noitemsep, label={}]
  \item Записать данные \eng{AA} по адресу \eng{AAA};
  \item Записать данные \eng{55} по адресу \eng{555};
  \item Записать данные \eng{80} по адресу \eng{AAA};
  \item Записать данные \eng{AA} по адресу \eng{AAA};
  \item Записать данные \eng{55} по адресу \eng{555};
  \item Записать данные \eng{30} по адресу сектора, который необходимо очистить.
\end{itemize}}
\par{Операция очистки сектора занимает существенное время, и пока она не закончится, невозможно произвести запись или чтение из \eng{flash}-памяти.}
\par{Операция полной очистки отличается только последним значением: для полной очистки данные \eng{30} записываются по адресу \eng{AAA}.}
\par{В \eng{datasheet} на \eng{S29AL032D} приведены следующие значения:
\begin{itemize}[noitemsep, label={}]
  \item Очистка сектора - до NN мкс.
  \item Полная очистка микросхемы - до NNN мкс.
\end{itemize}}


\subsection{Статус операции}
\par{Для того, чтобы контролировать завершение операций записи и очистки, а также отслеживать ошибки, которые могут возникнуть в процессе их выполнения необходимо получить информацию о статусе операции. Способы получения этой информации и её содержание приведены в разделе 12 \eng{datasheet}. Далее мы отметим наиболее важные для нас моменты.}
\par{Так как на отладочном стенде \eng{Altera DE1}, которым мы пользуемся для проведения лабораторных работ, не разведён сигнал \eng{BUSY} микросхемы \eng{S29AL032D}, то единственным способом получения статуса является чтение информации из адреса, по которому производилась запись.}
\par{Если операция удачно завершена --- то будет получено значение, из указанного адреса. Для операции записи оно должно совпадать с тем, которое мы хотели записать, а для операции очистки должно содержать только единицы (8'hFF).}
\par{Если операция ещё не завершена, то биты [7:2] считанного значения будут содержать информацию о статусе операции. Расшифровка значений этих битов приведена в Табл. \ref{table:status_bits}}
\par{До окончания операции записи DQ[7] будет иметь значение противоположное записываемому (\quotes{0} при очистке) - это основной признак того, что полученные данные отражают статус операции. Информация о битах статусного пакета приведена в Таблице \ref{table:op_status}}
\par{Обратите внимание, что при повторном чтении некоторые биты статусного пакета меняют своё значение на противоположное. Это сделано, чтобы убедиться, что операция чтения выполняется корректно и микросхема не \quotes{зависла}.}
\par{В информации о статусе операции есть важный признак: бит DQ[4] является признаком того, что время операции превысило максимально допустимое. Если этот бит принимает значение \quotes{1}, то во время операции произошла какая-то ошибка. В подавляющем большинстве случаев это происходит при попытке записи в ячейку памяти, уже содержавшую какое-то значение.}

\subsection{Проектирование контроллера Flash (продолжение)}
\par{Теперь, когда мы познакомились с операциями, которые предстоит выполнять контроллеру, мы можем продолжить его проектирование.}
\par{Контроллер должен обеспечивать операции чтения, записи и очистки микросхемы. Для этого он должен последовательно обмениваться данными и производить проверку статуса операций. Значит в качестве его основы следует применить конечный автомат. Ведь именно конечный автомат позволяет нам разделить режимы работы и реализовать алгоритмы работы в цифровых устройствах.}
\par{Начнём проектировать конечный автомат с начального состояния - состояния бездействия. Будем постепенно наращивать его сложность и степень детализации, уточняя некоторые особенности.}

% \begin{figure}[H]
% \centering
% \def\svgwidth{\columnwidth}
% \includesvg{flash_read_wave}
% \caption{Временная диаграмма чтения \eng{S29AL032D}}
% \label{fig:flash_read_wave}
% \end{figure}

\par{Из состояния бездействия возможны три различных перехода: операция чтения, операция записи и операция очистки.}

% \begin{figure}[H]
% \centering
% \def\svgwidth{\columnwidth}
% \includesvg{flash_read_wave}
% \caption{Временная диаграмма чтения \eng{S29AL032D}}
% \label{fig:flash_read_wave}
% \end{figure}

\par{Теперь выделим основные этапы, которые присутствуют в этих операциях. Прежде всего нас интересуют сложные операции \quotes{запись} и \quotes{очистка}.}
\par{Как уже говорилось, чтобы записать данные во \eng{flash}-память требуется провести четыре обмена с \eng{flash}-памятью. Но на этом нельзя заканчивать операцию, ведь необходимо дождаться окончания записи. Также надо учесть, что во время записи могут возникнуть ошибки.}
\par{Как мы уже говорили, для контроля статуса операции нам нужно считать данные из адреса, по которому производится запись и проанализировать их. Отразим это в состояниях конечного автомата.}

% \begin{figure}[H]
% \centering
% \def\svgwidth{\columnwidth}
% \includesvg{flash_read_wave}
% \caption{Временная диаграмма чтения \eng{S29AL032D}}
% \label{fig:flash_read_wave}
% \end{figure}

\par{Раньше мы не разделяли эти состояния и всё вместе называли \quotes{запись}. Но, постепенно уточняя детали, мы разбили сложную операцию на более простые этапы.}
\par{Аналогично поступим с операцией очистки.}

% \begin{figure}[H]
% \centering
% \def\svgwidth{\columnwidth}
% \includesvg{flash_memory_cell}
% \caption{Ячейка \eng{FLASH}-памяти}
% \label{fig:flash_memory_cell}
% \end{figure}

\par{Первое, что бросается в глаза - многократное повторение операций записи и чтения (которая используется при проверке статуса).}
\par{Также можно постараться выделить чтение и анализ статуса в отдельные состояния, общие для операций записи и очистки.}
\par{Тогда структура конечного автомата приобретает следующий вид:}

% \begin{figure}[H]
% \centering
% \def\svgwidth{\columnwidth}
% \includesvg{flash_memory_cell}
% \caption{Ячейка \eng{FLASH}-памяти}
% \label{fig:flash_memory_cell}
% \end{figure}

\par{В состояниях \eng{$W_n$} и \eng{$E_n$} происходит запись значения во flash-память. В состояниях \eng{$ST$} и \eng{$R$} происходит чтение.}
\par{Можем ли мы выделить операции чтения и записи и реализовать их отдельно, чтобы затем использовать их как показано на графе переходов?}
\par{Чтобы понять это, сначала ответим на вопрос как вообще возможно реализовать эти операции в контроллере.}
\par{Для того, чтобы провести чтение, необходимо развернуть временную диаграмму, показанную на Рис.\ref{fig:read_wave}. Тоже относится к записи: временную диаграмму записи, привязанную к тактовому сигналу, мы получили на Рис. \ref{fig:write_wave}}
\par{Как мы уже обсуждали, схема которую можно использовать для разделения событий во времени --- это конечный автомат. Например, чтобы реализовать операцию чтения, разобьём временную диаграмму чтения на этапы, и поставим каждому этапу в соответствие уникальное состояние, как представлено на Рис. \ref{fig:fsm_read_wave}}
\par{Мы могли бы добавить эти состояния в конечный автомат, который мы уже начали проектировать, но тогда нам пришлось бы каждое состояние чтения и записи разбить на несколько состояний. Это привело бы к ненужному усложнению структуры конечного автомата.}
\par{Вместо этого мы можем сделать отдельные небольшие модули, которые будут выполнять эти операции, и поместить автоматы в них. Например для операции чтения такой модуль будет управляться автоматом, представленным на Рис.\ref{fig:read_small_fsm}}
\par{Сигналом запуска для таких мини-автоматов будет признак того, что основной автомат находится в состоянии \quotes{чтение} или \quotes{запись}.}
\par{Состояние \quotes{завершено} нужно для того, чтобы выработать сигнал окончания работы. Иначе \quotes{большой} автомат не будет иметь возможности \quotes{узнать} о том, что операция завершена и можно переходить в следующее состояние.}
\par{Теперь, когда мы оформили все основные идеи и общую структуру контроллера, можно преступить к его реализации на \eng{Verilog HDL}.}
\par{Как всегда, начнём проектировать с интерфейса будущего контроллера - его входов и выходов. Так как контроллер будет обеспечивать доступ к памяти, мы хотели сделать его интерфейс похожим на интерфейс \eng{RAM}-памяти. Но нам придётся ввести дополнительные сигналы для того, чтобы реализовать операцию очистки и индикацию ошибок.}
\par{Нам будет достаточно одного входа для адреса, так как мы не можем одновременно производить чтение и запись во \eng{flash}-память.}
\par{Теперь опишем основной управляющий конечный автомат и мини-автомат чтения. Мини-автомат записи опишите самостоятельно.}
\par{Наладим связь между автоматами. Для этого определим управляющие сигналы (воздействия):}
\par{Начнём описывать исполняющую логику, которая будет задействована в различных состояниях:}
