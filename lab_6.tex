\chapter{Лабораторная работа №6\\\eng{FLASH} память} 

\section{Виды энергонезависимой памяти}

\par{Ни один из блоков цифровых устройств, которые мы рассмотрели ранее не способен хранить информацию при отсутствии питания.}

\par{Чтобы решить эту проблему, на заре вычислительной техники, данные в цифровое устройство после подачи питания загружали с таких носителей, как перфокарты и, позже, магнитные ленты. Ещё позже для целей хранения информации при отсутствии питания были разработаны накопители на гибких магнитных дисках --- дискетах и жёстких магнитных дисках --- \qeng{HDD}. На данный момент для хранения данных при отсутствии питания наиболее широко применяется \eng{FLASH}-память.}

\par{Энергонезависимые накопители информации обладают как преимуществами, так и недостатками по сравнению с энергозависимой \eng{RAM}-памяти.} 

\par{Как правило, энергонезависимая память существенно уступает по скорости работы \eng{RAM}-памяти. Это ограничение удалось преодолеть только недавно: в 2016 году была представлена постоянная память, где информация хранится в виде спина электрона. Такая память по скорости работы не уступает современной \eng{RAM}-памяти, такой как \eng{DDR5}. Но подобная память ещё долгое время будет оставаться недоступной для рядового пользователя из-за высокой стоимости и малой степени освоения технологии серийного производства 10нм.}

\section{Принципы работы \eng{FLASH}-памяти}

\par{В качестве элемента хранения информации \eng{FLASH}-память использует транзистор с плавающим затвором, где состояние затвора определяет бит хранимой информации, изображённый на Рис.\ref{fig:flash_memory_cell}}

% \begin{figure}[H]
% \centering
% \def\svgwidth{\columnwidth}
% \includesvg{flash_memory_cell}
% \caption{Ячейка \eng{FLASH}-памяти}
% \label{fig:flash_memory_cell}
% \end{figure}

\par{Рассмотрим работу такого транзистора.}

\par{Как вы видите, он содержит два затвора: управляющий и плавающий. Плавающий полностью находится в диэлектрике и при этом способен накапливать электроны. От величины накопленного заряда меняется \quotes{лёгкость} с которой транзистор открывается --- т.е. величина напряжения \quotes{управляющий затвор---исток}, при которой через транзистор начнёт течь ток.}

\par{Для хранения информации используют следующий принцип (см.Рис.\ref{fig:flash_cell_read}): чтобы считать информацию, на управляющий затвор подаётся напряжение чтения --- среднее между самым сильным (в диэлектрике нет электронов) и самым слабым (в диэлектрике максимум электронов). Если транзистор открывается, значит в плавающем затворе были электроны и мы считаем, что в нём записан \quotes{0}, если не открывается, значит электронов в плавающем затворе нет и записана \quotes{1}.}

% \begin{figure}[H]
% \centering
% \def\svgwidth{\columnwidth}
% \includesvg{flash_cell_read}
% \caption{Чтение из ячейки \eng{FLASH}-памяти}
% \label{fig:flash_cell_read}
% \end{figure}

\par{Осталось понять как можно \quotes{заставить} электроны попадать в плавающий затвор, ведь он изолирован диэлектриком. Не вдаваясь в подробности скажем, что если подать достаточно высокое напряжение \quotes{управляющий затвор---сток}, то у электронов хватит энергии, чтобы \quotes{перескочить} диэлектрик и попасть в плавающий затвор. А если изменить полярность этого напряжения, то можно заставить электроны покинуть плавающий затвор (см.Рис.\ref{fig:flash_cell_write}).}

% \begin{figure}[H]
% \centering
% \def\svgwidth{\columnwidth}
% \includesvg{flash_cell_write}
% \caption{Запись в ячейку \eng{FLASH}-памяти}
% \label{fig:flash_cell_write}
% \end{figure}

\par{Самое важное в этой идее то, что если электроны попали в плавающий затвор они не могут самостоятельно покинуть его через диэлектрик и будут оставаться там в течении многих лет. Таким образом и достигается сохранение записанной информации при отсутствии питания.}

\par{Теперь мы знаем, что для того чтобы записать или считать информацию из \eng{FLASH}-памяти надо использовать большую разность потенциалов. Но на самом деле транзистор устроен таким образом, что энергия, необходимая чтобы \quotes{загнать} электроны в плавающий затвор меньше энергии, необходимой, чтобы их \quotes{выгнать}. Это делается чтобы при чтении значения электроны не покидали плавающий затвор.}

\par{При такой организации становится сложно обеспечить очистку каждого транзистора в отдельности, поэтому обычно стирается целая группа ячеек.}

\par{Из-за особенностей транзистора с плавающим затвором, которые мы рассмотрели можно выделить следующие характерные черты \eng{FLASH}-памяти:
\begin{itemize}
  \item Запись значения возможна только из логической \quotes{1} в логический \quotes{0};
  \item Удаление информации возможно только из группы ячеек одновременно (блока);
  \item Удаление и запись информации приводят к деградации ячеек памяти;
  \item Чтение также приводит к деградации ячеек памяти, но в меньшей степени.
\end{itemize}}

\par{На Рисунке\ref{fig:flash_structure} изображена общая структура \eng{FLASH}-памяти. Как видно она практически не отличается от \eng{RAM}-памяти: из ячеек строится матрица, контролируемая управляющим блоком. А сам управляющий блок обеспечивает коммуникацию с внешними устройствами, дешифрацию адреса и управление записью и чтением массива элементов памяти. Подключение \eng{FLASH}-памяти и управление ей со стороны цифрового устройства полностью зависит от того, как реализован блок управления --- доступ к содержимому \eng{FLASH}-памяти может быть синхронный или асинхронный, по последовательной или параллельной шине, с разделением шин адреса и данных или без него.}

% \begin{figure}[H]
% \centering
% \def\svgwidth{\columnwidth}
% \includesvg{flash_structure}
% \caption{Ячейка \eng{FLASH}-памяти}
% \label{fig:flash_structure}
% \end{figure}

\section{Чип \eng{FLASH}-памяти \eng{S29AL032D}}

\par{Для практического знакомства с \eng{FLASH}-памятью мы спроектируем контроллер микросхемы \eng{S29AL032D}. Именно эта микросхема установлена на отладочной плате Altera DE1.}
\par{Основным источником информации о любой микросхеме служат технические условия (англ. \eng{datasheet}). В большинстве случаев в этом документе содержатся все необходимые сведения для использования микросхемы: электрические параметры, размеры и тип корпуса, информация о выводах, и многие другие сведения. В том числе \eng{datasheet} содержит данные о протоколах информационного обмена.}
\par{В нашем случае микросхема уже подключена, поэтому из всего \eng{datasheet} нас прежде всего интересует каким образом необходимо взаимодействовать с данной микросхемой, чтобы записать или считать данные.}
\par{Для разработки контроллера следует ознакомиться со следующими разделами документа:
\begin{itemize}[noitemsep,label={}]
  \item 11. \eng{Commands Definitions};
  \item 12. \eng{Write Operation Status};
  \item 17. \eng{AC Characteristics}.
\end{itemize}}
\par{Далее будут приведены необходимые выдержки из документа, однако настоятельно рекомендуем ознакомиться с ним.}

\subsection{Проектирование контроллера \eng{S29AL032D}}
\par{Контроллер, как мы уже знаем, предназначен для обмена информацией с внешними цифровыми устройствами. Он должен предоставлять удобный и простой интерфейс внутри нашего цифрового устройства и обеспечивать все необходимые взаимодействия с внешним устройством, избавляя остальные блоки от необходимости реализовывать эти функции.}
\par{Как должен работать наш контроллер и как он управляться?}
\par{Если мы хотим работать с памятью, то для нас наиболее важными являются операции записи и чтения данных.  Тогда наиболее удобным для нас был бы уже знакомый интерфейс, похожий на \eng{RAM}-память: данные для записи, данные для чтения, адрес и управляющие сигналы.}
\par{Для того чтобы начать реализовывать контроллер, нам нужно изучить операции записи и чтения в микросхемы \eng{S29AL032D}}

\subsection{Операция чтения}
\par{Для чтения данных из микросхемы \eng{S29AL032D} не требуется никакой дополнительной подготовки. Временная диаграмма чтения приведена в пункте 17.2 \eng{datasheet} и представлена на Рис.\ref{fig:flash_read_wave}}

% \begin{figure}[H]
% \centering
% \def\svgwidth{\columnwidth}
% \includesvg{flash_read_wave}
% \caption{Временная диаграмма чтения \eng{S29AL032D}}
% \label{fig:flash_read_wave}
% \end{figure}

\par{Времена, указанные на диаграмме, приведены в Табл. \ref{table:flash_read_timings}}

% \tabcolsep=0.11cm
\begin{table}[htbp]
  \centering
  \small
  \begin{tabular}{l|l|c|c}
    Обозн. & Описание & Min & Max \\
    \hline
    $t_{RC}$ & Продолжительность цикла чтения & 70нс & 90нс\\
    $t_{ACC}$ & Задержка Адрес --- Данные & 70нс & 90нс\\
    $t_{CE}$ & Задержка Выбор Чипа --- Данные & 70нс & 90нс\\
  \end{tabular}
  \caption{Временные характеристики операции чтения \eng{S29AL032D}}
  \label{table:flash_read_timings}
\end{table}

\par{Как мы уже знаем, единственным источником информации о времени для цифрового устройства может являться только сигнал синхронизации, заранее известной частоты. Привяжем времена, упомянутые в Таблице \ref{table:flash_read_timings} к тактовому сигналу частоты 50 МГц, которым тактируется устройство. При этом учтём, что некоторые задержки могут быть равны нулю. Полученная временная диаграмма показана на Рис. \ref{figure:clocked_flash_read}}

\begin{figure}[H]
\begin{tikztimingtable}[%
    timing/dslope=0.1,
    timing/.style={x=5ex,y=2ex},
    x=5ex,
    timing/rowdist=3ex,
    timing/name/.style={font=\sffamily\scriptsize},
]
  CLK50        & 18{c} \\
  ADDRESS      & 2u 4D{Read\ Addr.} 2u \\
  \nsig{CE}    & 2H 4L 4H \\
  \nsig{OE}    & 3H 3L 4H \\
  \nsig{WE}    & 1L 5H 4L \\
  \nsig{RESET} & 10H \\
  DATA         & 4Z 2D{Output\ Data} 2Z \\
  RY/\nsig{BY} & 10H \\
\extracode
\begin{pgfonlayer}{background}
\begin{scope}[semitransparent ,semithick]
\vertlines[darkgray,dotted]{0.5,1.5 ,...,8.0}
\end{scope}
\end{pgfonlayer}
\end{tikztimingtable}
\caption{Временная диаграмма операции чтения шины \eng{PCI}}
\end{figure}

\subsection{Операция записи}
\par{Обычно запись во \eng{flash}-память - более сложная операция, чем чтение. Многие производители защищают чипы \eng{flash}-памяти от случайной записи и используют для записи специальные последовательности команд. Согласно \eng{datasheet S29AL032D} (разделы 7 и 11) для того, чтобы записать данные необходимо выполнить следующую последовательность из 4-х операций:
\begin{itemize}[noitemsep, label={}]
  \item Записать данные \eng{AA} по адресу \eng{AAA};
  \item Записать данные \eng{55} по адресу \eng{555};
  \item Записать данные \eng{A0} по адресу \eng{AAA};
  \item Записать нужные данные по указанному адресу.
\end{itemize}
}
\par{Согласно \eng{datasheet} данные записываются не мгновенно. На то, чтобы провести операцию записи одного слова требуется порядка 11 мкс.}
\par{Также крайне важно, что при записи данных микросхема \eng{S29AL032D} может менять значение с \quotes{1} на \quotes{0}.}
\par{Чтобы поменять значение с \quotes{0} на \quotes{1} требуется очистка целого фрагмента памяти, называемого сектором, либо полная очистка всей микросхемы!}
\par{Для того, чтобы мы могли полноценно пользоваться микросхемой \eng{S29AL032D} нам потребуется реализовать в контроллере функции очистки, поэтому изучим как происходят эти операции в данной микросхеме.}

\subsection{Операция очистки}
\par{Для очистки выбранного сектора необходимо выполнить следующую последовательность операций:
\begin{itemize}[noitemsep, label={}]
  \item Записать данные \eng{AA} по адресу \eng{AAA};
  \item Записать данные \eng{55} по адресу \eng{555};
  \item Записать данные \eng{80} по адресу \eng{AAA};
  \item Записать данные \eng{AA} по адресу \eng{AAA};
  \item Записать данные \eng{55} по адресу \eng{555};
  \item Записать данные \eng{30} по адресу сектора, который необходимо очистить.
\end{itemize}}
\par{Операция очистки сектора занимает существенное время, и пока она не закончится, невозможно произвести запись или чтение из \eng{flash}-памяти.}
\par{В \eng{datasheet} на \eng{S29AL032D} приведены следующие значения:
\begin{itemize}[noitemsep, label={}]
  \item Очистка сектора - до NN мкс.
  \item Полная очистка микросхемы - до NNN мкс.
\end{itemize}}


\subsection{Статус операции}
\par{Для того, чтобы контролировать завершение операций записи и очистки, а также отслеживать ошибки, которые могут возникнуть в процессе их выполнения необходимо получить информацию о статусе операции. Способы получения этой информации и её описание приведены в разделе 12 \eng{datasheet}. Здесь мы отметим наиболее важные для нас моменты.}
\par{Так как на отладочном стенде \eng{Altera DE1}, которым мы пользуемся для проведения лабораторных работ, не разведён сигнал \eng{BUSY} \eng{S29AL032D}, то единственным способом получения статуса является чтение информации из адреса, по которому производилась запись.}
\par{Если операция удачно завершена - то будет получено значение, из указанного адреса. Если проходила операция записи - то значение должно совпадать с тем, которое мы хотели записать, а если происходила операция очистки, то полученное значение должно содержать только единицы (8'hFF).}
\par{Если операция ещё не завершена, то во время исполнения встроенного алгоритма биты [7:2] будут содержать информацию о статусе операции.}
\par{До окончания операции записи DQ[7] будет иметь значение противоположное записываемому (инверсия при записи, или \quotes{0} при очистке) - это основной признак того, что полученные данные отражают статус операции. Информация о битах статусного пакета приведена в Таблице \ref{table:op_status}}
\par{Обратите внимание, что при повторном чтении некоторые биты статусного пакета меняют своё значение на противоположное. Это сделано, для дополнительно индикации того, что в данный момент выполняется операция.}
\par{В информации о статусе операции есть важный признак: бит DQ[4] является признаком того, что время операции превысило максимально допустимое. Если этот бит принимает значение \quotes{1}, то во время операции произошла какая-то ошибка. В подавляющем большинстве случаев это случается в случае записи в ячейку памяти, уже содержавшую какое-то значение.}

\subsection{Проектирование контроллера Flash}
\par{Теперь, когда мы познакомились с операциями, которые предстоит выполнять контроллеру, мы можем продолжить его проектирование.}
\par{От контроллера потребуется проводить различные операции, последовательно отправлять посылки, читать и анализировать информацию о Статусе операции. Значит в качестве его основы следует применить конечный автомат. Ведь именно конечный автомат позволяет нам разделить режимы работы и реализовать последовательности действий в цифровых устройствах.}
\par{Начнём проектировать конечный автомат с начального состояния - состояния бездействия. Будем постепенно наращивать его сложность и степень детализации, уточняя некоторые особенности.}
\par{Из состояния бездействия возможны три различных перехода: операция чтения , операция записи и операция очистки.}
\par{Теперь выделим основные этапы, которые присутствуют в этих операциях. Прежде всего нас интересуют сложные операции \quotes{запись} и \quotes{очистка}.}
\par{Как уже говорилось, чтобы провести запись требуется провести 4 обмена с \eng{flash}-памятью. Но на этом нельзя заканчивать операцию, ведь необходимо дождаться окончания записи. К тому же во время записи могут возникнуть ошибки.}
\par{Как мы уже говорили для контроля статуса операции нам нужно считать данные из адреса, по которому производится запись и проанализировать их. Отразим это в состояниях конечного автомата. Нам также нужно учесть, что может произойти ошибка.}
\par{Раньше мы не разделяли эти состояния и всё вместе называли \quotes{запись}. Но после уточнения Того, что на самом деле происходит в устройстве мы разбили сложную операцию на более простые этапы.}
\par{Этапы операции очистки будут выглядеть абсолютно идентично. Это может означать, что некоторые решения можно спроектировать таким образом, что получится их использовать в различных ветках нашего конечного автомата.}
\par{Первое, что бросается в глаза - многократное повторение операций записи и чтения (которая используется при проверке статуса). Чтобы выполнить эти операции нужно развернуть временные диаграммы, которые мы получили на Рис.\ref{fig:some_fig} и Рис. \ref{fig:some_fig2}, соответственно. Нам хотелось бы выделить эти операции для того, чтобы упростить наш конечный автомат. Тогда можно будет представить его следующим образом:}

% \begin{figure}[H]
% \centering
% \def\svgwidth{\columnwidth}
% \includesvg{flash_memory_cell}
% \caption{Ячейка \eng{FLASH}-памяти}
% \label{fig:flash_memory_cell}
% \end{figure}

\par{Также можно постараться выделить чтение и анализ статуса в отдельные состояния , общие для операций записи и очистки.}
\par{Тогда структура конечного автомата приобретает следующий вид:}

% \begin{figure}[H]
% \centering
% \def\svgwidth{\columnwidth}
% \includesvg{flash_memory_cell}
% \caption{Ячейка \eng{FLASH}-памяти}
% \label{fig:flash_memory_cell}
% \end{figure}

\par{В состояниях \eng{$W$} и \eng{$E$} происходит запись значения во flash-память. В состояниях ST и R происходит чтение значения.}
\par{Можем ли мы выделить операции чтения и записи и реализовать их отдельно, чтобы затем использовать их как показано на графе переходов?}
\par{Чтобы понять это, сначала ответим на вопрос как вообще возможно реализовать эти операции в контроллере.}
\par{Для того, чтобы провести чтение, необходимо развернуть временную диаграмму, показанную на Рис.\ref{fig:read_wave}. Тоже относится к записи: временную диаграмму записи, привязанную к тактовому сигналу, мы получили на Рис. \ref{fig:write_wave}}
\par{Как мы уже обсуждали, схема которую можно использовать для разделения событий во времени - это конечный автомат. Например, с его помощью можно реализовать операцию чтения следующим образом: разобьём состояние \quotes{чтение} на этапы, которые соответствуют этапам на временной диаграмме, как представлено на Рис.\ref{fig:fsm_read_wave}}
\par{Мы могли бы добавить эти состояния в конечный автомат, который мы уже начали проектировать, но тогда нам пришлось бы каждое состояние чтения разбить на несколько состояний, тоже самое пришлось бы сделать с записью.}
\par{Вместо этого мы можем сделать отдельные небольшие модули, которые будут выполнять эти операции, поместить автоматы в них. Например для операции чтения такой модуль будет управляться автоматом, представленным на Рис.\ref{fig:read_small_fsm}}
\par{Сигналом запуска для таких мини-автоматов будет признак того, что основной автомат находится в состоянии \quotes{чтение} или \quotes{запись}.}
\par{Состояние \quotes{завершено} нужно для того, чтобы выработать сигнал окончания работы. Иначе \quotes{большой} автомат не будет иметь возможности \quotes{узнать} о том, что операция завершена и можно переходить в следующее состояние.}
\par{Теперь, когда мы оформили все основные идеи и общую структуру контроллера, можно преступить к его реализации на \eng{Verilog HDL}.}
\par{Как всегда, начнём проектировать с интерфейса будущего контроллера - его входов и выходов. Так как контроллер будет обеспечивать доступ к памяти, мы хотели сделать его интерфейс похожим на интерфейс \eng{RAM}-памяти. Но нам придётся ввести дополнительные сигналы для того, чтобы реализовать операцию очистки и индикацию ошибок.}
\par{Нам будет достаточно одного входа для адреса, так как мы не можем одновременно производить чтение и запись во \eng{flash}-память.}
\par{Теперь опишем основной управляющий конечный автомат и мини-автомат чтения. Мини-автомат записи опишите самостоятельно.}
\par{Наладим связь между автоматами. Для этого определим управляющие сигналы (воздействия):}
\par{Начнём описывать исполняющую логику, которая будет задействована в различных состояниях:}
